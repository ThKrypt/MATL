% This is the function definition master file. It is used for reading from the MATL compiler, and for generating LaTeX content.
%   Comment lines start with "%" symbol
%   Columns are separated by tabs, and are as follows:
%     - source: MATL source code
%     - minIn: minimum number of inputs. This is interpreted as a string that goes to the compiled code directly
%     - maxIn: default number of inputs. A string too
%     - defIn: default number of inputs
%     - altIn: alternative number of inputs
%     - minOut: minimum number of outputs
%     - maxOut: maximum number of outputs
%     - defOut: default number of outputs. A string too
%     - altOut: alternative number of outputs
%     - consumeInputs: whether used inputs are removed from the stack
%     - wrap: whether function body should be wrapped at all
%     - funInClipboard: whether function inputs should overwrite clipboard
%     - allowedOnline: whether function is allowed in the online compiler
%     - body: function body. May span several lines, leaving first column empty
%     - comment (for matl program)
%     - description (for LaTeX)
%
% src	minIn	maxIn	defIn	altIn	minOut	maxOut	defOut	altOut	consumeInputs	wrap	funInClipboard	allowedOnline	body	Comment (for matl)	description (for LaTex)
!	1	2	1	2	1	1	1		true	true	true	true	if numel(in)==1, if ndims(in{1})==2, out{1} = in{1}.'; else, out{1} = permute(in{1}, [2 1 3:ndims(in{1})]); end	transpose / permute array dimensions	If $1$ input: \matlab+.'+ (\matlab+transpose+), or \matlab+permute(..., [2 1 ...])+ for multidimensional arrrays. If $2$ inputs: \matlab+permute+. If the second input is 1, 2 or 3 it indicates which dimension is not permuted for a 3D array; that is, it corresponds to [1 3 2], [3 2 1] or [2 1 3] respectively
													else
													if isequal(in{2}, 1), in{2} = [1 3 2]; elseif isequal(in{2}, 2), in{2} = [3 2 1]; elseif isequal(in{2}, 3), in{2} = [2 1 3]; end
													out{1} = permute(in{:});
													end
X!	1	2	2		1	1	1		true	true	true	true	out{1} = rot90(in{:});	rotate array in steps of 90 degrees	\matlab+rot90+
Y!	1	1	1		0	2	2		true	true	true	false	[out{:}] = system(in{:});	execute system command	\matlab+system+
Z!	1	1	1		1	1	1		true	true	true	true	out{1} = full(in{1});	convert sparse matrix to full matrix	\matlab+full+
"
X"	2	inf	3		1	1	1		true	true	true	true	out{1} = repmat(in{:});	replicate and tile array	\matlab+repmat+
Y"	2	inf	2	3	1	1	1		true	true	true	true	if numel(in)==2 && ~isvector(in{2}), in{2} = in{2}(:); end	replicate elements of array	\matlab+repelem+ (run-length decoding). With $2$ inputs: if the first or second inputs are empty the output is empty. Else, the second input is linearized if needed; and if the first or second input is shorter than the other, entries are repeated cyclically to match lengths
													if isempty(in{1}) || isempty(in{2})
													out{1} = in{1}([]);
													else
													if numel(in)==2 && ~isscalar(in{2}) && numel(in{1}) < numel(in{2}), in{1} = in{1}(mod(0:numel(in{2})-1, numel(in{1}))+1); end
													if numel(in)==2 && ~isscalar(in{1}) && numel(in{2}) < numel(in{1}), in{2} = in{2}(mod(0:numel(in{1})-1, numel(in{2}))+1); end
													out{1} = repelem(in{:});
													end
Z"	1	1	1		1	1	1		true	true	true	true	S = ' ';	string or array of blanks	\matlab+blanks+. It allows vector input, and in that case it produces a matrix or multidimensional array
													if numel(in{1})<=1, y = S(ones(1,in{1}));
													else, y = S(ones(in{1}));
													end
													out{1} = y; clear S
#
X#	0	0	0		0	0	0		false	false	false	true	disp('/-------'), celldisp(STACK), disp('-------/')	display stack contents	display stack as a cell array
Y#	2	inf	2	3	0	0	0		true	true	true	true	if numel(in)==2	sound / soundsc / audiowrite	(i) With $2$ inputs: \matlab+sound+. If second input is \matl+T+, it is interpreted as \matl+44100+. If second input is \matl+F+, it is interpreted as \matl+44100+ and \matlab+audiowrite+ is called instead of \matlab+sound+, with file name \matlab+'audio.wav'+. (ii) With $3$ inputs: if third input is a truthy scalar, \matlab+soundsc+ is called with the first two inputs. If third input is a numeric vector of size $2$, \matlab+soundsc+ is called with the three inputs. In both cases, \matl+T+ in second input is interpreted as \matl+44100+. If third input is a string, it defines a file name, and \matlab+audiowrite+ is called with that file name and the other two inputs. (iii) With more than $3$ inputs: \matlab+audiowrite+ is called using the third input as file name. Further inputs specify parameter-value pairs. \matl+T+ in second input is interpreted as \matl+44100+. 
													if islogical(in{2})&&isscalar(in{2})&&in{2}
													sound(in{1},44100)
													elseif islogical(in{2})&&isscalar(in{2})&&~in{2}
													audiowrite('audio.wav',in{1},44100);
													else
													sound(in{:})
													end
													elseif numel(in)==3
													if islogical(in{2})&&isscalar(in{2})&&in{2}, in{2} = 44100; end
													if isscalar(in{3})&&in{3}
													soundsc(in{1},in{2})
													elseif isnumeric(in{3})&&numel(in{3})==2
													soundsc(in{:})
													elseif ischar(in{3})
													audiowrite(in{3},in{1},in{2})
													else
													error('MATL:runtime', 'MATL run-time error: input not allowed');
													end
													else
													if islogical(in{2})&&isscalar(in{2})&&in{2}, in{2} = 44100; end
													audiowrite(in{3},in{1},in{2},in{4:end})
													end
Z#	1	3	1	2	0	0	0		true	true	true	false	data = in{1}; if ~iscell(data), data = {data}; end	write to file	Writes first input to file \comp{inout}, creating it if necessary. If the file exists, by default its previous contents are overwritten. If the input is a numeric or char array each entry is treated as a raw byte and written. Behaviour is undefined for entries exceeding $255$. If the input is a cell array, the contents of each cell are written, with a byte $10$ (representing newline) in between. With $2$ inputs: second input specifies file name; it is converted to char is necessary; if empty defaults to \comp{inout}. With $3$ inputs: third input specifies whether previous contents of the file should be kept
													sep = 10;
													if numel(in)>=2 && ~isempty(in{2}), file = in{2}; else file = 'inout'; end
													if numel(in)>=3 && in{3}, perm = 'a'; else perm = 'w'; end
													if ~ischar(file), file = char(file); end
													fid = fopen(file, perm);
													for n = 1:numel(data)
													fwrite(fid, data{n});
													if n<numel(data), fwrite(fid, sep); end
													end
													fclose(fid); clear file sep
$
X$	1	inf	2	2	0	inf	1		true	true	true	false	[out{:}] = feval(in{:});	execute Matlab function	execute Matlab function specified by first input, using the rest of the inputs as arguments.
Y$	1	2	2		1	1	1		true	true	true	true	out{1} = char(vpa(in{:}));	variable precision arithmetic	\matlab+char(vpa(...))+
Z$	0	1	0	1	1	1	1		true	true	true	false	if ~numel(in) || isempty(in{1}), in{1} = 'inout'; end; fid = fopen(in{1}, 'r');	read from file	Reads bytes from specifed file. Each individual byte is then converted to a char, and the output is a row vector of char. If $0$ inputs or empty input: file name is \comp{inout}.
													x = reshape(char(fread(fid,inf,'*uint8')),1,[]);
													fclose(fid); out{1} = x;
%
X%	1	1	1		1	1	1		true	true	true	true	out{1} = class(in{1});	class	class of input (\matlab+class+ with one input)
Y%	2	3	2		1	1	1		true	true	true	true	str = {'uint8' 'int8' 'uint64' 'int64' 'uint16' 'int16' 'uint32' 'int32' 'double' 'single'};	cast to data type	\matlab+cast+. This function allows strings in second input to be replaced by numbers, as follows: 1: \matlab+'uint8'+, 2: \matlab+'int8'+, 3: \matlab+'uint64'+, 4: \matlab+'int64'+, 5: \matlab+'uint16'+, 6: \matlab+'int16'+, 7: \matlab+'uint32'+, 8: \matlab+'int32'+, 9: \matlab+'double'+, 10: \matlab+'single'+
													if isnumeric(in{2}), in(2) = str(in{2}); end; clear str
													out{1} = cast(in{:});
Z%	2	2	2		1	1	1		true	true	true	true	str = {'uint8' 'int8' 'uint64' 'int64' 'uint16' 'int16' 'uint32' 'int32' 'double' 'single'};	convert datatypes without changing underlying data	\matlab+typecast+. This function allows strings in second input to be replaced by numbers, as follows: 1: \matlab+'uint8'+, 2: \matlab+'int8'+, 3: \matlab+'uint64'+, 4: \matlab+'int64'+, 5: \matlab+'uint16'+, 6: \matlab+'int16'+, 7: \matlab+'uint32'+, 8: \matlab+'int32'+, 9: \matlab+'double'+, 10: \matlab+'single'+
													if isnumeric(in{2}), in(2) = str(in{2}); end; clear str
													out{1} = typecast(in{:});
&
X&	2	4	2	3	1	3	1		true	true	true	true	str = {'rows' 'stable' 'sorted'};	set intersection	\matlab+intersect+. Uses the \matlab+'stable'+ flag by default. If one input is char and the other is numeric, the latter is converted to char. This function allows flag strings in third and subsequent inputs to be replaced by numbers, as follows: 1: \matlab+'rows'+, 2: \matlab+'stable'+, 3: \matlab+'sorted'+
													for k = 3:numel(in), if isnumeric(in{k}), in(k) = str(in{k}); end; end;	clear str
													if ischar(in{1}) && isnumeric(in{2}), in{2} = char(in{2}); end
													if ischar(in{2}) && isnumeric(in{1}), in{1} = char(in{1}); end
													if numel(in)==2 || (numel(in)==3 && strcmp(in{3},'rows')), in{end+1}='stable'; end, [out{:}] = intersect(in{:});
Y&	0	inf	2	numel(STACK)	1	1	1		true	true	true	true	if isempty(in), y = true; else y = in{1}; for n=2:numel(in), y = bsxfun(@and, y, in{n}); end; end; if numel(in)==1, y = logical(y); end; out{1} = y; clear y n;	logical 'and' (element-wise, singleton expansion)	\matlab+&+ (\matlab+and+), element-wise with singleton expansion
Z&	2	3	2		1	1	1		true	true	true	true	if ischar(in{1}), in{1} = double(in{1}); end; if ischar(in{2}), in{2} = double(in{2}); end	bit-wise logical 'and' (element-wise, singleton expansion)	\matlab+bitand+ (bitwise 'and'), element-wise with singleton expansion. If first or second inputs are \matlab+char+ they are converted to \matlab+double+. \matlab+double+ inputs are rounded. If the inputs are \matlab+double+ they can have negative values, and in that case they must be in the range from \matlab+-2^52+ up to \matlab+2^52-1+. \sa \matl+Z|+, \matl+Z~+
													in{1} = round(in{1}); in{2} = round(in{2});
													if any(in{1}(:)<0) || any(in{2}(:)<0), neg = true; else neg = false; end
													if neg, in{1} = mod(in{1}, 2^53); in{2} = mod(in{2}, 2^53); end;
													if max(size(in{1}))==1 || max(size(in{2}))==1 || isequal(size(in{1}), size(in{2}))
													out{1} = bitand(in{:});
													else
													nd = max(ndims(in{1}), ndims(in{2})); sz1 = arrayfun(@(n)size(in{1},n), 1:nd); sz2 = arrayfun(@(n)size(in{2},n), 1:nd);
													assert(all(sz1==sz2 | sz1==1 | sz2==1), 'MATL:runtime', 'MATL run-time error: inputs have incompatible sizes')
													rm1 = ones(1,nd); rm1(sz1==1) = sz2(sz1==1); rm2 = ones(1,nd); rm2(sz2==1) = sz1(sz2==1);
													insx1 = repmat(in{1}, rm1); insx2 = repmat(in{2}, rm2); out{1} = bitand(insx1, insx2, in{3:end});
													clear nd sz1 sz2 rm1 rm2 insx1 insx2
													end
													if neg, out{1} = mod(out{1} - 2^52, 2^53) - 2^52; end; clear neg
'
X'
Y'	1	1	1		2	2	2	[false true]	true	true	true	true	data = in{1}(:);	run-length encoding	run-length encoding (inverse of \matlab+repelem+). Input may be an array or cell array. Numeric values must be finite
													if isempty(in{1}), if iscell(in{1}), out={{} []}; else, out={[] []}; end;
													else
													if ~iscell(in{1}), ch = [1; find(diff(data))+1; numel(data)+1];
													else ch = 1; for n=2:numel(data), if ~isequal(data{n-1},data{n}), ch = [ch; n]; end; end; ch = [ch; numel(data)+1]; end
													result = {data(ch(1:end-1)), diff(ch)};
													if ndims(in{1})==2 && size(in{1},1)==1, result{1} = result{1}.'; result{2} = result{2}.'; end
													[out{:}] = result{:};
													end
Z'	0	1	0	1	1	1	1		true	true	true	true	if numel(in)==0, out{1} = now;	current date and time	\matlab+now+. With $1$ input: the input should be numeric with values from 1 to 6, which are used as indices into the output of \matlab+clock+
													elseif numel(in)==1, c = clock; out{1} = c(in{1});
													else error('MATL:runtime', 'MATL run-time error: too many inputs'); end
(	3	inf	3	4	1	1	1		true	true	true	true	if numel(in)==3 && iscell(in{3})	assignment ( ) indexing	assignment \matlab+( )+ indexing. Null assignment (\matlab+x(...) = []+) can only be done with a single index. \sa \matl+Y(+, \matl+Z(+
													arrayDestination = in{1};
													arrayData = in{2};
													indices = in{3};
													Ni = numel(indices);
													numelmax = max(cellfun(@numel, indices));
													for n = 1:Ni
													if isscalar(indices{n}), indices{n} = repmat(indices{n},1,numelmax); else indices{n} = reshape(indices{n},1,[]); end
													end; clear numelmax
													indmat = vertcat(indices{:});
													for k = 1:size(indmat,2)
													indcol = indmat(:,k);
													sz = size(arrayDestination);
													if Ni<numel(sz), sz = [ sz(1:Ni-1) prod(sz(Ni:end)) ]; elseif Ni>numel(sz), sz = [ sz ones(1,Ni-numel(sz)) ]; end
													indcol = round(indcol);
													nonpos = indcol<=0;
													indcol(nonpos) = mod(indcol(nonpos).'-1,sz(nonpos))+1;
													indcol = num2cell(indcol);
													if ~isempty(arrayData), arrayDestination(indcol{:}) = arrayData((k-1)*(numel(arrayData)>1)+1);
													else arrayDestination(indcol{:}) = [];
													end
													end
													out{1} = arrayDestination;
													clear arrayDestination arrayData indices indmat indcol nonpos Ni sz n k
% Above is for "element-wise" indexing; below is "normal"
													else
													arrayDestination = in{1};
													arrayData = in{2};
													indices = in(3:end);
													Ni = numel(indices);
													sz = size(arrayDestination);
													if Ni<numel(sz), sz = [ sz(1:Ni-1) prod(sz(Ni:end)) ]; elseif Ni>numel(sz), sz = [ sz ones(1,Ni-numel(sz)) ]; end
													for n = 1:Ni
													if ~islogical(indices{n}) && any(imag(indices{n}(:)))
													indices{n} = num2cell(real(indices{n})+sz(n)*imag(indices{n}));
													if numel(indices{n})==1, indices{n} = indices{n}{1}; else shape = find(size(indices{n})>1,1); indices{n} = colon(indices{n}{:}); indices{n} = shiftdim(indices{n}(:),1-shape); end
													end
													if ~islogical(indices{n}) && ~ischar(indices{n})
													indices{n} = round(indices{n});
													ind = indices{n}<=0;
													indices{n}(ind) = mod(indices{n}(ind)-1,sz(n))+1;
													end; clear ind
													end
													if ~isempty(arrayData), arrayDestination(indices{:}) = arrayData;
													else arrayDestination(indices{:}) = [];
													end
													out{1} = arrayDestination;
													clear arrayDestination arrayData indices Ni sz n
													end
% This code above was easy, after the code for ) had been done
% shiftdim is needed to preserve end-index shape (the colon operation gives a row vector both for say [1 0] and [1;0]). I realized this here, with assignment indexing. For referencing indexing and for curly-brace indexing it probably doesn't matter, but I also add the shiftdim operation there just in case
% `data = []; x=[5 4 7]; x([1 3]) = data;` doesn't work. It has to be `data = []; x=[5 4 7]; x([1 3]) = [];`. In addition, for indexing with various indices, all of them except for one should be `:`. But MATL doesn't have `:`. So assignment with [] only works with one index.
X(	3	inf	3		1	1	1		true	true	true	true	assert(iscell(in{1}), 'MATL:runtime', 'MATL run-time error: a cell array is needed as first input')	assignment {} indexing	assignment \matlab+{ }+ indexing
													if numel(in)==3, in{4} = 1; end; Ni = in{end};
													if in{end}==1 && iscell(in{end-1})
													indices = in{end-1};
													Ni = numel(indices);
													data = in(2:end-2);
													arrayDestination = in{1};
													numelmax = max(cellfun(@numel, indices));
													for n = 1:Ni
													if isscalar(indices{n}), indices{n} = repmat(indices{n},1,numelmax); else indices{n} = reshape(indices{n},1,[]); end
													end; clear numelmax
													indmat = vertcat(indices{:});
													for k = 1:size(indmat,2)
													indcol = indmat(:,k);
													sz = size(arrayDestination);
													if Ni<numel(sz), sz = [ sz(1:Ni-1) prod(sz(Ni:end)) ]; elseif Ni>numel(sz), sz = [ sz ones(1,Ni-numel(sz)) ]; end
													indcol = round(indcol);
													nonpos = indcol<=0;
													indcol(nonpos) = mod(indcol(nonpos).'-1,sz(nonpos))+1;
													indcol = num2cell(indcol);
													arrayDestination(indcol{:}) = data((k-1)*(numel(data)>1)+1);
													end
													out{1} = arrayDestination;
													clear arrayDestination data indices indmat indcol nonpos Ni sz n k
% Above is for "element-wise" indexing; below is "normal"
													else
													Ni = in{end};
													indices = in(end-Ni:end-1);
													data = in(2:end-Ni-1);
													arrayDestination = in{1};
													sz = size(arrayDestination);
													if Ni<numel(sz), sz = [ sz(1:Ni-1) prod(sz(Ni:end)) ]; elseif Ni>numel(sz), sz = [ sz ones(1,Ni-numel(sz)) ]; end
													for n = 1:Ni
													if ~islogical(indices{n}) && any(imag(indices{n}(:)))
													indices{n} = num2cell(real(indices{n})+sz(n)*imag(indices{n}));
													if numel(indices{n})==1, indices{n} = indices{n}{1}; else shape = find(size(indices{n})>1,1); indices{n} = colon(indices{n}{:}); indices{n} = shiftdim(indices{n}(:),1-shape); end
													end
													if ~islogical(indices{n}) && ~ischar(indices{n})
													indices{n} = round(indices{n});
													ind = indices{n}<=0;
													indices{n}(ind) = mod(indices{n}(ind)-1,sz(n))+1;
													end; clear ind
													end
													nei = cellfun(@nnz, indices);
													if numel(nei)==1, nei = [nei 1]; end
													arrayDestination(indices{:}) = reshape(data, nei);
													out{1} = arrayDestination;
													clear arrayDestination data indices Ni sz n
													end
% This code above was based on that for (.
% An added difficulty is that `[arrayDestination{indices{:}}] = deal(data{:})` doesn't work (but explicitly writing the indices does work!: [arrayDestination{1:2, 3:4}] = deal(data{:}) ). So I had to use () indexing on the LHS and reshape on the RHS
% nnz works for numeric, logical or char indices
Y(	2	inf	3		1	1	1		true	true	true	true	arrayDestination = in{1};	assignment ( ) indexing with final colon	assignment \matlab+(..., :)+ indexing. Null assignment (\matlab+x(..., :) = []+) can only be done with a single index (in addition to the implicit colon). \sa \matl+(+, \matl+Z(+
													arrayData = in{2};
													indices = [in(3:end) {':'}];
													Ni = numel(indices);
													sz = size(arrayDestination);
													if Ni<numel(sz), sz = [ sz(1:Ni-1) prod(sz(Ni:end)) ]; elseif Ni>numel(sz), sz = [ sz ones(1,Ni-numel(sz)) ]; end
													for n = 1:Ni
													if ~islogical(indices{n}) && any(imag(indices{n}(:)))
													indices{n} = num2cell(real(indices{n})+sz(n)*imag(indices{n}));
													if numel(indices{n})==1, indices{n} = indices{n}{1}; else shape = find(size(indices{n})>1,1); indices{n} = colon(indices{n}{:}); indices{n} = shiftdim(indices{n}(:),1-shape); end
													end
													if ~islogical(indices{n}) && ~ischar(indices{n})
													indices{n} = round(indices{n});
													ind = indices{n}<=0;
													indices{n}(ind) = mod(indices{n}(ind)-1,sz(n))+1;
													end; clear ind
													end
													if ~isempty(arrayData), arrayDestination(indices{:}) = arrayData;
													else arrayDestination(indices{:}) = [];
													end
													out{1} = arrayDestination;
% The code for Y( is the same as it was for ( before introducing element-wise indexing, except for the `indices = ...` line
Z(	2	inf	3		1	1	1		true	true	true	true	arrayDestination = in{1};	assignment ( ) indexing with initial colon	assignment \matlab+(:, ...)+ indexing. Null assignment (\matlab+x(:, ...) = []+) can only be done with a single index (in addition to the implicit colon). \sa \matl+(+, \matl+Y(+
													arrayData = in{2};
													indices = [{':'} in(3:end)];
													Ni = numel(indices);
													sz = size(arrayDestination);
													if Ni<numel(sz), sz = [ sz(1:Ni-1) prod(sz(Ni:end)) ]; elseif Ni>numel(sz), sz = [ sz ones(1,Ni-numel(sz)) ]; end
													for n = 1:Ni
													if ~islogical(indices{n}) && any(imag(indices{n}(:)))
													indices{n} = num2cell(real(indices{n})+sz(n)*imag(indices{n}));
													if numel(indices{n})==1, indices{n} = indices{n}{1}; else shape = find(size(indices{n})>1,1); indices{n} = colon(indices{n}{:}); indices{n} = shiftdim(indices{n}(:),1-shape); end
													end
													if ~islogical(indices{n}) && ~ischar(indices{n})
													indices{n} = round(indices{n});
													ind = indices{n}<=0;
													indices{n}(ind) = mod(indices{n}(ind)-1,sz(n))+1;
													end; clear ind
													end
													if ~isempty(arrayData), arrayDestination(indices{:}) = arrayData;
													else arrayDestination(indices{:}) = [];
													end
													out{1} = arrayDestination;
% The code for Z( is the same as it was for ( before introducing element-wise indexing, except for the `indices = ...` line
)	2	inf	2		1	2	1	2	true	true	true	true	if numel(in)==2 && iscell(in{2})	reference ( ) indexing / split array	reference \matlab+( )+ indexing. If $2$ outputs: only one input index can be used. The second output produces the "complementary" array \matlab+y=x; y(ind)=[]+, where \matlab+y+ and \matlab+ind+ are the inputs. \sa \matl+Y)+, \matl+Z)+
													array = in{1};
													indices = in{2};
													Ni = numel(indices);
													[~,nmax] = max(cellfun(@numel, indices));
													for n = [1:nmax-1 nmax+1:Ni]
													if isscalar(indices{n}), indices{n} = repmat(indices{n}, size(indices{nmax})); else indices{n} = reshape(indices{n}, size(indices{nmax})); end
													end; clear nmax
													sz = size(array);
													if Ni<numel(sz), sz = [ sz(1:Ni-1) prod(sz(Ni:end)) ]; elseif Ni>numel(sz), sz = [ sz ones(1,Ni-numel(sz)) ]; end
													if numel(sz)==1, sz = [sz 1]; end
													for n = 1:Ni, indices{n} = mod(round(indices{n})-1,sz(n))+1; end
													indices = {sub2ind(sz, indices{:})};
% Above is for "element-wise" indexing; below is "normal"
													else
													array = in{1};
													indices = in(2:end);
													Ni = numel(indices);
													sz = size(array);
													if Ni<numel(sz), sz = [ sz(1:Ni-1) prod(sz(Ni:end)) ]; elseif Ni>numel(sz), sz = [ sz ones(1,Ni-numel(sz)) ]; end
													for n = 1:Ni
													if ~islogical(indices{n}) && any(imag(indices{n}(:)))
													indices{n} = num2cell(real(indices{n})+sz(n)*imag(indices{n}));
													if numel(indices{n})==1, indices{n} = indices{n}{1}; else shape = find(size(indices{n})>1,1); indices{n} = colon(indices{n}{:}); indices{n} = shiftdim(indices{n}(:),1-shape); end
													end
													if ~islogical(indices{n}) && ~ischar(indices{n})
													indices{n} = mod(round(indices{n})-1,sz(n))+1;
													end
													end
													end
													out{1} = array(indices{:});
													if nout>1, y = array; if ~isvector(y), y = y(:).'; end; y(indices{:}) = []; out{2} = y; end
													clear indices array Ni sz n
% This code above for ) indexing has been a little difficult. It had to correctly handle an arbitrary number of indices, possibly with partially linear indexing; and end-based indexing. Then I added modular indexing (for scalar indices). / Then I changed end-based indexing, which allowed me to modular indexing not only for scalar indices. Then came element-wise indexing
% Indexing can be done with chars, but then modulo and rounding are not applied (hence `if ~islogical(indices{n}) && ~ischar(indices{n})` and not just `if ~islogical(indices{n})`). This is because `':'` used as an index has a special meaning in Matlab, and also in MATL
% That `isvector` above is needed because `y = [1 3 5; 2 4 6]; y([1 3 5]) = []` gives `[2 4 6]` in Matlab but `[2; 4; 6]` in Octave (4.0.0). The pattern seems to be: if ~isvector(y), Matlab reshapes as a row, whereas Octave reshapes as a column
X)	2	inf	2		0	inf	-1		true	true	true	true	assert(iscell(in{1}), 'MATL:runtime', 'MATL run-time error: a cell array is needed as first input')	reference {} indexing	reference \matlab+{ }+ indexing
													if numel(in)==2 && iscell(in{2})
													array = in{1};
													indices = in{2};
													Ni = numel(indices);
													[~,nmax] = max(cellfun(@numel, indices));
													for n = [1:nmax-1 nmax+1:Ni]
													if isscalar(indices{n}), indices{n} = repmat(indices{n}, size(indices{nmax})); else indices{n} = reshape(indices{n}, size(indices{nmax})); end
													end; clear nmax
													sz = size(array);
													if Ni<numel(sz), sz = [ sz(1:Ni-1) prod(sz(Ni:end)) ]; elseif Ni>numel(sz), sz = [ sz ones(1,Ni-numel(sz)) ]; end
													if numel(sz)==1, sz = [sz 1]; end
													for n = 1:Ni, indices{n} = mod(round(indices{n})-1,sz(n))+1; end
													indices = {sub2ind(sz, indices{:})};
% Above is for "element-wise" indexing; below is "normal"
													else
													array = in{1};
													assert(iscell(array), 'MATL:runtime', 'MATL run-time error: a cell array is needed as first input')
													indices = in(2:end);
													Ni = numel(indices);
													sz = size(array);
													if Ni<numel(sz), sz = [ sz(1:Ni-1) prod(sz(Ni:end)) ]; elseif Ni>numel(sz), sz = [ sz ones(1,Ni-numel(sz)) ]; end
													for n = 1:Ni
													if ~islogical(indices{n}) && any(imag(indices{n}(:)))
													indices{n} = num2cell(real(indices{n})+sz(n)*imag(indices{n}));
													if numel(indices{n})==1, indices{n} = indices{n}{1}; else shape = find(size(indices{n})>1,1); indices{n} = colon(indices{n}{:}); indices{n} = shiftdim(indices{n}(:),1-shape); end
													end
													if ~islogical(indices{n}) && ~ischar(indices{n})
													indices{n} = mod(round(indices{n})-1,sz(n))+1;
													end
													end
													end
													out = reshape(array(indices{:}),1,[]);
													if nout>=0, out = out(1:nout); end
													clear indices array Ni sz n
Y)	1	inf	2		1	2	1	2	true	true	true	true	array = in{1};	reference ( ) indexing with final colon	reference \matlab+(..., :)+ indexing. If $2$ outputs: only one input index can be used. The second output produces the "complementary" array \matlab+y=x; y(ind,:)=[]+, where \matlab+y+ and \matlab+ind+ are the inputs. \sa \matl+)+, \matl+Z)+
													indices = [in(2:end) {':'}];
													Ni = numel(indices);
													sz = size(array);
													if Ni<numel(sz), sz = [ sz(1:Ni-1) prod(sz(Ni:end)) ]; elseif Ni>numel(sz), sz = [ sz ones(1,Ni-numel(sz)) ]; end
													for n = 1:Ni
													if ~islogical(indices{n}) && any(imag(indices{n}(:)))
													indices{n} = num2cell(real(indices{n})+sz(n)*imag(indices{n}));
													if numel(indices{n})==1, indices{n} = indices{n}{1}; else shape = find(size(indices{n})>1,1); indices{n} = colon(indices{n}{:}); indices{n} = shiftdim(indices{n}(:),1-shape); end
													end
													if ~islogical(indices{n}) && ~ischar(indices{n})
													indices{n} = mod(round(indices{n})-1,sz(n))+1;
													end
													end
													out{1} = array(indices{:});
													if nout>1, y = array; y(indices{:}) = []; out{2} = y; end
% Y) is the same as ) was before introducing element-wise indexing, except for the `indices = ...` line
Z)	1	inf	2		1	2	1	2	true	true	true	true	array = in{1};	reference ( ) indexing with initial colon	reference \matlab+(:, ...)+ indexing. If $2$ outputs: only one input index can be used. The second output produces the "complementary" array \matlab+y=x; y(:,ind)=[]+, where \matlab+y+ and \matlab+ind+ are the inputs. \sa \matl+)+, \matl+Y)+
													indices = [{':'} in(2:end)];
													Ni = numel(indices);
													sz = size(array);
													if Ni<numel(sz), sz = [ sz(1:Ni-1) prod(sz(Ni:end)) ]; elseif Ni>numel(sz), sz = [ sz ones(1,Ni-numel(sz)) ]; end
													for n = 1:Ni
													if ~islogical(indices{n}) && any(imag(indices{n}(:)))
													indices{n} = num2cell(real(indices{n})+sz(n)*imag(indices{n}));
													if numel(indices{n})==1, indices{n} = indices{n}{1}; else shape = find(size(indices{n})>1,1); indices{n} = colon(indices{n}{:}); indices{n} = shiftdim(indices{n}(:),1-shape); end
													end
													if ~islogical(indices{n}) && ~ischar(indices{n})
													indices{n} = mod(round(indices{n})-1,sz(n))+1;
													end
													end
													out{1} = array(indices{:});
													if nout>1, y = array; y(indices{:}) = []; out{2} = y; end
% Z) is the same as ) was before introducing element-wise indexing, except for the `indices = ...` line
*	1	inf	2	1	1	1	1		true	true	true	true	if numel(in)==1, in{2} = in{1}.'; end	array product (element-wise, singleton expansion)	\matlab+.*+ (\matlab+times+), element-wise with singleton expansion. If $1$ input: a second input is used given by the first transposed
													y = in{1}; for n=2:numel(in), y = bsxfun(@times, y, in{n}); end;
													out{1} = y; clear y n;
X*	2	2	2		1	1	1		true	true	true	true	out{1} = kron(double(in{1}), double(in{2}));	Kronecker tensor product	\matlab+kron+
Y*	2	2	2		1	1	1		true	true	true	true	if islogical(in{1}), in{1} = double(in{1}); end	matrix product	matrix product, \matlab+*+ (\matlab+mtimes+)
													if islogical(in{2}), in{2} = double(in{2}); end
													out{1} = in{1}*in{2};
Z*	1	inf	2	numel(STACK)	1	1	1		true	true	true	true	n = numel(in); combs = cell(1,n);	Cartesian product	Cartesian product. Given a number $n$ of arrays of possibly different sizes, generates an $n$-column matrix whose rows describe all combinations of elements taken from those arrays
													[combs{end:-1:1}] = ndgrid(in{end:-1:1});
													combs = cat(n+1, combs{:}); combs = reshape(combs,[],n);
													out{1} = combs; clear combs n
+	1	inf	2	1	1	1	1		true	true	true	true	if numel(in)==1, in{2} = in{1}.'; end	addition (element-wise, singleton expansion)	\matlab|+| (\matlab+plus+), element-wise with singleton expansion. If $1$ input: a second input is used given by the first transposed
													y = in{1}; for n=2:numel(in), y = bsxfun(@plus, y, in{n}); end;
													out{1} = y; clear y n;
X+
Y+	2	3	2	3	1	1	1		true	true	true	true	str = {'same' 'valid' 'full'};	two-dimensional convolution	\matlab+conv2+. Doesn't allow two-vector and one matrix mode. Converts first two inputs to \matlab+double+. This function allows flag strings in third and subsequent inputs to be replaced by numbers, as follows: 1: \matlab+'same'+, 2: \matlab+'valid'+, 3: \matlab+'full'+. \sa \matl|Z+|
													for k = 3:numel(in), if isnumeric(in{k}), in(k) = str(in{k}); end; end; clear str
													if issparse(in{1}), in{1} = full(in{1}); end; if issparse(in{2}), in{2} = full(in{2}); end
													out{1} = conv2(double(in{1}), double(in{2}), in{3:end});
Z+	2	2	2		1	1	1		true	true	true	true	if issparse(in{1}), in{1} = full(in{1}); end; if issparse(in{2}), in{2} = full(in{2}); end	two-dimensional convolution; maintains size	\matlab+conv2(..., 'same')+. Converts inputs to \matlab+double+. \sa \matl|Y+|
													out{1} = conv2(double(in{1}), double(in{2}), 'same');
,
X,	1	1	1		1	1	1		true	true	true	true	out{1} = cos(in{1});	cosine (radians)	\matlab+cos+
Y,	1	1	1		1	1	1		true	true	true	true	out{1} = sin(in{1});	sine (radians)	\matlab+sin+
Z,	1	1	1		1	1	1		true	true	true	true	out{1} = tan(in{1});	tangent (radians)	\matlab+tan+
-	1	2	2	1	1	1	1		true	true	true	true	if numel(in)==1, in{2} = in{1}.'; end	subtraction (element-wise, singleton expansion)	\matlab+-+ (\matlab+minus+), element-wise with singleton expansion. If $1$ input: a second input is used given by the first transposed
													out{1} = bsxfun(@minus, in{1}, in{2});
X-	2	4	2	3	1	2	1		true	true	true	true	str = {'rows' 'stable' 'sorted'};	set difference	\matlab+setdiff+. Uses the \matlab+'stable'+ flag by default. If one input is char and the other is numeric, the latter is converted to char. This function allows flag strings in third and subsequent inputs to be replaced by numbers, as follows: 1: \matlab+'rows'+, 2: \matlab+'stable'+, 3: \matlab+'sorted'+. \sa \matl+X~+
													for k = 3:numel(in), if isnumeric(in{k}), in(k) = str(in{k}); end; end; clear str
													if ischar(in{1}) && isnumeric(in{2}), in{2} = char(in{2}); end
													if ischar(in{2}) && isnumeric(in{1}), in{1} = char(in{1}); end
													if numel(in)==2, in{3}='stable'; end, [out{:}] = setdiff(in{:});
Y-	2	2	2		1	2	2	1	true	true	true	true	[out{:}] = deconv(in{:});	deconvolution and polynomial division	\matlab+deconv+
Z-
.
X.
Y.	0	1	1		0	0	0		true	true	true	true	pause(in{:})	pause	\matlab+pause+ (without outputs)
Z.	2	3	2		1	1	1		true	true	true	true	if ischar(in{1}), in{1} = double(in{1}); end	get bit	\matlab+bitget+. If first input is \matlab+char+ it is automatically converted to \matlab+double+
													out{1} = bitget(in{:});
/	2	2	2		1	1	1		true	true	true	true	out{1} = bsxfun(@rdivide, in{1}, in{2});	array right division (element-wise, singleton expansion)	\matlab+./+ (\matlab+rdivide+), element-wise with singleton expansion
X/	1	1	1		1	1	1		true	true	true	true	out{1} = angle(in{1});	phase angle (radians)	\matlab+angle+
Y/	2	2	2		1	1	1		true	true	true	true	out{1} = in{1}/in{2};	right matrix division	right matrix division, \matlab+/+ (\matlab+mrdivide+)
Z/	1	3	1		1	1	1		true	true	true	true	out{1} = unwrap(in{:});	unwrap phase angle	\matlab+unwrap+
0
X0	1	1	1		1	1	1		true	true	true	true	fn = 'X0'; k = find(preLit.(fn).key==in{1}, 1);	predefined literals	predefined literal depending on input
													assert(~isempty(k), 'MATL:runtime', 'MATL run-time error: input not allowed in function %s', fn);
													out{1} = preLit.(fn).val{k};
Y0	1	1	1		1	1	1		true	true	true	true	fn = 'Y0'; k = find(preLit.(fn).key==in{1}, 1);	predefined literals	predefined literal depending on input
													assert(~isempty(k), 'MATL:runtime', 'MATL run-time error: input not allowed in function %s', fn);
													out{1} = preLit.(fn).val{k};
Z0
1
X1	1	1	1		1	1	1		true	true	true	true	fn = 'X1'; k = find(preLit.(fn).key==in{1}, 1);	predefined literals	predefined literal depending on input
													assert(~isempty(k), 'MATL:runtime', 'MATL run-time error: input not allowed in function %s', fn);
													out{1} = preLit.(fn).val{k};
Y1	1	1	1		1	1	1		true	true	true	true	fn = 'Y1'; k = find(preLit.(fn).key==in{1}, 1);	predefined literals	predefined literal depending on input
													assert(~isempty(k), 'MATL:runtime', 'MATL run-time error: input not allowed in function %s', fn);
													out{1} = preLit.(fn).val{k};
Z1
2
X2	1	1	1		1	1	1		true	true	true	true	fn = 'X2'; k = find(preLit.(fn).key==in{1}, 1);	predefined literals	predefined literal depending on input
													assert(~isempty(k), 'MATL:runtime', 'MATL run-time error: input not allowed in function %s', fn);
													out{1} = preLit.(fn).val{k};
Y2	1	1	1		1	1	1		true	true	true	true	fn = 'Y2'; k = find(preLit.(fn).key==in{1}, 1);	predefined literals	predefined literal depending on input
													assert(~isempty(k), 'MATL:runtime', 'MATL run-time error: input not allowed in function %s', fn);
													out{1} = preLit.(fn).val{k};
Z2
3
X3	1	1	1		1	1	1		true	true	true	true	fn = 'X3'; k = find(preLit.(fn).key==in{1}, 1);	predefined literals	predefined literal depending on input
													assert(~isempty(k), 'MATL:runtime', 'MATL run-time error: input not allowed in function %s', fn);
													out{1} = preLit.(fn).val{k};
Y3	1	1	1		1	1	1		true	true	true	true	fn = 'Y3'; k = find(preLit.(fn).key==in{1}, 1);	predefined literals	predefined literal depending on input
													assert(~isempty(k), 'MATL:runtime', 'MATL run-time error: input not allowed in function %s', fn);
													out{1} = preLit.(fn).val{k};
Z3
4
X4	1	1	1		1	1	1		true	true	true	true	fn = 'X4'; k = find(preLit.(fn).key==in{1}, 1);	predefined literals	predefined literal depending on input
													assert(~isempty(k), 'MATL:runtime', 'MATL run-time error: input not allowed in function %s', fn);
													out{1} = preLit.(fn).val{k};
Y4	1	1	1		1	1	1		true	true	true	true	fn = 'Y4'; k = find(preLit.(fn).key==in{1}, 1);	predefined literals	predefined literal depending on input
													assert(~isempty(k), 'MATL:runtime', 'MATL run-time error: input not allowed in function %s', fn);
													out{1} = preLit.(fn).val{k};

Z4
5
X5	1	1	1		1	1	1		true	true	true	true	fn = 'X5'; k = find(preLit.(fn).key==in{1}, 1);	predefined literals	predefined literal depending on input
													assert(~isempty(k), 'MATL:runtime', 'MATL run-time error: input not allowed in function %s', fn);
													out{1} = preLit.(fn).val{k};
Y5	1	1	1		1	1	1		true	true	true	true	fn = 'Y5'; k = find(preLit.(fn).key==in{1}, 1);	predefined literals	predefined literal depending on input
													assert(~isempty(k), 'MATL:runtime', 'MATL run-time error: input not allowed in function %s', fn);
													out{1} = preLit.(fn).val{k};
Z5
6
X6	1	1	1		1	1	1		true	true	true	true	fn = 'X6'; k = find(preLit.(fn).key==in{1}, 1);	predefined literals	predefined literal depending on input
													assert(~isempty(k), 'MATL:runtime', 'MATL run-time error: input not allowed in function %s', fn);
													out{1} = preLit.(fn).val{k};
Y6	1	1	1		1	1	1		true	true	true	true	fn = 'Y6'; k = find(preLit.(fn).key==in{1}, 1);	predefined literals	predefined literal depending on input
													assert(~isempty(k), 'MATL:runtime', 'MATL run-time error: input not allowed in function %s', fn);
													out{1} = preLit.(fn).val{k};
Z6
7
X7	1	1	1		1	1	1		true	true	true	true	fn = 'X7'; k = find(preLit.(fn).key==in{1}, 1);	predefined literals	predefined literal depending on input
													assert(~isempty(k), 'MATL:runtime', 'MATL run-time error: input not allowed in function %s', fn);
													out{1} = preLit.(fn).val{k};
Y7
Z7
8
X8	1	1	1		1	1	1		true	true	true	true	fn = 'X8'; k = find(preLit.(fn).key==in{1}, 1);	predefined literals	predefined literal depending on input
													assert(~isempty(k), 'MATL:runtime', 'MATL run-time error: input not allowed in function %s', fn);
													out{1} = preLit.(fn).val{k};
Y8
Z8
9
X9	1	1	1		1	1	1		true	true	true	true	fn = 'X9'; k = find(preLit.(fn).key==in{1}, 1);	predefined literals	predefined literal depending on input
													assert(~isempty(k), 'MATL:runtime', 'MATL run-time error: input not allowed in function %s', fn);
													out{1} = preLit.(fn).val{k};
Y9
Z9
:	1	3	1	2	1	1	1		true	true	true	true	if numel(in)==1 && iscell(in{1}), in = in{1}; end	range; vector of equally spaced values	\matlab+colon+ (with three inputs \matlab+x+, \matlab+y+, \matlab+z+ produces \matlab+x:y:z+; with two inputs \matlab+x+, \matlab+y+ produces \matlab+x:y+). If one input: produces \matlab+1:x+, or \matlab+' ':x+ if \matlab+x+ is char. For a single cell-array input, the contents of the cell array are interpreted as the actual inputs.
													if numel(in)==1
													if ischar(in{1}), s = ' '; else s = 1; end
													out{1} = colon(s,in{:}); clear s
													else
													out{1} = colon(in{:}); end
X:	1	1	1		1	1	1		true	true	true	true	out{1} = in{1}(:);	linearize to column array	linearize to column array (index with \matlab+(:)+)
Y:	1	1	1		0	inf	numel(in{1})		true	true	true	true	assert(iscell(in{1}), 'MATL:runtime', 'MATL run-time error: a cell array is needed as input');	unbox cell array	generate comma-separated list from cell array (index with \matlab+{:}+) and push each element onto stack
													out = reshape(in{1}(1:nout),1,[]);
Z:	2	4	3		1	1	1		true	true	true	true	if ischar(in{1}), in{1} = double(in{1}); end	set bit	\matlab+bitset+. If first input is \matlab+char+ it is automatically converted to \matlab+double+
													out{1} = bitset(in{:});
;
X;	1	1	1		1	1	1		true	true	true	true	out{1} = acos(in{1});	inverse cosine (radians)	\matlab+acos+
Y;	1	1	1		1	1	1		true	true	true	true	out{1} = asin(in{1});	inverse sine (radians)	\matlab+asin+
Z;	2	2	2		1	1	1		true	true	true	true	out{1} = bsxfun(@atan2, in{1}, in{2});	four quadrant inverse tangent (radians; element-wise, singleton expansion)	\matlab+atan2+, element-wise with singleton expansion
<	1	2	2	1	1	1	1		true	true	true	true	if numel(in)==1, in{2} = in{1}.'; end	is less than? (element-wise, singleton expansion)	\matlab+<+ (\matlab+lt+), element-wise with singleton expansion. If $1$ input: a second input is used given by the first transposed
													out{1} = bsxfun(@lt, in{1}, in{2});
X<	1	3	1		1	2	1	[false true]	true	true	true	true	if numel(in)==2, out{1} = bsxfun(@min, in{1}, in{2});	minimum	\matlab+min+. If $2$ inputs: element-wise with singleton expansion. With more than $2$ inputs, the second is replaced by \matl+[]+. This function does not support flags \matlab+'omitnan'+ or \matlab+'includenan'+. Output is \matlab+char+ if input is. \sa \matl+X>+, \matl+Xl+
													elseif numel(in)==1, [out{:}] = min(in{:});
													else in{2} = []; [out{:}] = min(in{:}); end
													if (numel(in)==1 && ischar(in{1})) || (numel(in)==2 && ischar(in{1}) && ischar(in{2})) || (numel(in)==3 && ischar(in{1}) && isempty(in{2})), out{1} = char(out{1}); end
Y<	1	3	1	2	1	1	1		true	true	true	true	c = ischar(in{1}); if c, in{1} = double(in{1}); end	cumulative minimum	\matlab+cummin+. Output is \matlab+char+ if input is. \sa \matl+Y>+
													out{1} = cummin(in{:});
													if c, out{1} = char(out{1}); end; clear c
Z<
=	1	2	2	1	1	1	1		true	true	true	true	if numel(in)==1, in{2} = in{1}.'; end	is equal? (element-wise, singleton expansion)	\matlab+==+ (\matlab+eq+), element-wise with singleton expansion. If $1$ input: a second input is used given by the first transposed
													out{1} = bsxfun(@eq, in{1}, in{2});
X=	0	inf	2	numel(STACK)	1	1	1		true	true	true	true	if numel(in)>=2, out{1} = isequal(in{:}); else out{1} = true; end	true if arrays are numerically equal	\matlab+isequal+. Works for any number of inputs
Y=	2	2	2		1	1	1		true	true	true	true	if isnumeric(in{1}), in{1} = char(in{1}); end; if isnumeric(in{2}), in{2} = char(in{2}); end; out{1} = strcmp(in{:});	compare strings	\matlab+strcmp+. If first or second inputs are numeric they are converted to char
Z=
>	1	2	2	1	1	1	1		true	true	true	true	if numel(in)==1, in{2} = in{1}.'; end	is greater than? (element-wise, singleton expansion)	\matlab+>+ (\matlab+gt+), element-wise with singleton expansion. If $1$ input: a second input is used given by the first transposed
													out{1} = bsxfun(@gt, in{1}, in{2});
X>	1	3	1		1	2	1	[false true]	true	true	true	true	if numel(in)==2, out{1} = bsxfun(@max, in{1}, in{2});	maximum	\matlab+max+. If $2$ inputs: element-wise with singleton expansion. With more than $2$ inputs, the second is replaced by \matl+[]+. This function does not support flags \matlab+'omitnan'+ or \matlab+'includenan'+. Output is \matlab+char+ if input is. \sa \matl+X<+, \matl+Xl+
													elseif numel(in)==1, [out{:}] = max(in{:});
													else in{2} = []; [out{:}] = max(in{:}); end
													if (numel(in)==1 && ischar(in{1})) || (numel(in)==2 && ischar(in{1}) && ischar(in{2})) || (numel(in)==3 && ischar(in{1}) && isempty(in{2})), out{1} = char(out{1}); end
Y>	1	3	1	2	1	1	1		true	true	true	true	c = ischar(in{1}); if c, in{1} = double(in{1}); end	cumulative maximum	\matlab+cummax+. Output is \matlab+char+ if input is. \sa \matl+Y<+
													out{1} = cummax(in{:});
													if c, out{1} = char(out{1}); end; clear c
Z>
?
X?
Y?	0	0	0		1	1	1		true	true	true	true	x = { 'V=..90+r~/,~6=..90+~0/*p~J69,9~5+~0/~''6%' 'U*w+~=22~Q=*2=<w+~8=)2*p~U*w+~49=2/)+p~U*w+~6/2:507~19~<=;3}' 'Uw(9~+990~.,/7,=1+~%/)~.9/.29~''/)2:0w*~<9259(9' 'J69~.,/7,=119,~6=+~<990~:,503507r~0/*~19' 'U~:5:~5*~8/,~19p~U~2539:~5*p~U~''=+~7//:~=*~5*' 'E/)~4)+*~6=(90w*~9=,09:~5*~%9*r~<=<%' 'Q%~;/:9~5+~.,/<291=*5;' 'E/)~399.~)+507~*6=*~8)0;*5/0p~U~:/~0/*~*6503~5*~19=0+~''6=*~%/)~*6503~5*~19=0+' 'J65+~5+~/<(5/)+2%~+/19~+*,=079~)+9~/8~*69~8)0;*5/0~wE_w~*6=*~U~''=+0w*~.,9(5/)+2%~=''=,9~/8' 'N,/7,=1+~1=3507~.,/7,=1+~q~6/''~.9,(9,+9}' 'G9~099:~*/~7/~:99.9,' }; if ~numel(in), in{1} = randi(numel(x)); end; if numel(in{1})>1, error('MATL:runtime', 'MATL run-time error: input not allowed'); end; out{1} = char(158-x{mod(in{1}-1,numel(x))+1}); clear x	answer why	answer why. Sort of
Z?	1	6	3		1	1	1		true	true	true	true	out{1} = sparse(in{:});	create sparse matrix	\matlab+sparse+
@
X@
Y@	1	2	1	2	1	1	1		true	true	true	true	if numel(in)==1	all possible permutations / variations	If $1$ input: \matlab+perms+. If $2$ inputs: variations (without repetition). In either case, the results are sorted
													out{1} = sortrows(perms(in{:}));
													else
													n = in{2}; combs = cell(1,n);
													x = 1:numel(in{1});
													[combs{end:-1:1}] = ndgrid(x);
													combs = cat(n+1, combs{:}); combs = reshape(combs,[],n);
													combs = combs(all(diff(sort(combs,2),[],2),2), :);
													combs = in{1}(combs);
													out{1} = sortrows(combs); clear combs n x
													end
% Variations are computed like Cartesian power (variations with repetitions), and then results with repetitions are removed
Z@	1	3	1	2	1	1	1		true	true	true	true	c = ischar(in{1});	random permutation	\matlab+randperm+ (produces a row vector as output). If $3$ inputs: third input indicates number of permutations, each on a different row. If first input is char it is interpreted as population (not as size)
													if c, x = in{1}; in{1} = numel(in{1}); end
													if numel(in)~=3, out{1} = randperm(in{:});
													else [~, p] = sort(rand(in{3},in{1}),2); p = p(:,1:in{2}); out{1} = p; end
													if c, out{1} = x(out{1}); end
													clear p c x
A	1	2	1	2	1	1	1		true	true	true	true	out{1} = all(in{:});	all	\matlab+all+. \sa \matl|XA|
XA	1	1	1		1	1	1		true	true	true	true	out{1} = all(in{:},1);	all, along first dimension	\matlab+all(..., 1)+. \sa \matl|A|
YA	2	3	2	3	1	1	1		true	true	true	true	if islogical(in{2}) && isequal(in{2}, false), in{2} = 0:9;	convert integer to string representation in given base	(i) \matlab+dec2base+. (ii) If second input has more than one element: it defines the symbols, which can be characters or numbers. The number of symbols defines the base, which can exceed $36$. (iii) If second input is a negative number \matlab+-n+: it is interpreted as symbols \matlab+0:n-1+ (case ii). (i, ii) Base \matl+0+ is interpreted as \matl+10+, \matl+1+ as \matl+16+, \matl+F+ as \matl+0:9+, \matl+T+ as \matl+0:15+. \sa \matl+ZA+, \matl+Za+
													elseif islogical(in{2}) && isequal(in{2}, true), in{2} = 0:15;
													elseif isnumeric(in{2}) && isequal(in{2}, 0), in{2} = 10;
													elseif isnumeric(in{2}) && isequal(in{2}, 1), in{2} = 16;
													elseif isnumeric(in{2}) && isscalar(in{2}) && in{2}<0, in{2} = 0:-in{2}-1;
													end
													if numel(in{2})==1, out{1} = dec2base(in{:});
													else d = in{1}(:); symbols = in{2}(:).'; b = numel(symbols);
													if ~(isnumeric(d) || ischar(d)) || any(d ~= floor(d)) || any(d < 0) || any(d > 1/eps)
													error(message('MATLAB:dec2base:FirstArg')); end
													if numel(in)>2 && (~isscalar(in{3}) || ~(isnumeric(in{3}) || ischar(in{3})) || in{3} ~= floor(in{3}) || in{3} < 0)
													error(message('MATLAB:dec2base:ThirdArg')); end
													if isempty(d)
													out{1} = [];
													else
													d = double(d);
													n = max(1,round(log2(max(d)+1)/log2(b)));
													while any(b.^n <= d), n = n + 1; end
													if numel(in)>2, n = max(n,in{3}); end
													s(:,n) = rem(d,b);
													while any(d) && n >1, n = n - 1; d = floor(d/b); s(:,n) = rem(d,b); end
													s = reshape(symbols(s + 1),size(s));
													out{1} = s;
													clear d n b s
													end
													end
% Adapted from dec2base
ZA	2	2	2		1	1	1		true	true	true	true	if islogical(in{2}) && isequal(in{2}, false), in{2} = 0:9;	convert string in given base to decimal integer	(i) \matlab+base2dec+. (ii) If second input has more than one element: it defines the symbols, which can be characters (case-sensitive) or numbers. The number of symbols defines the base, which can exceed $36$. (iii) If second input is a negative number \matlab+-n+: it is interpreted as symbols \matlab+0:n-1+ (case ii). (i, ii, iii) Non-recognized digits are ignored. Base \matl+0+ is interpreted as \matl+10+, \matl+1+ as \matl+16+, \matl+F+ as \matl+0:9+, \matl+T+ as \matl+0:15+. \sa \matl+YA+, \matl+Za+
													elseif islogical(in{2}) && isequal(in{2}, true), in{2} = 0:15;
													elseif isnumeric(in{2}) && isequal(in{2}, 0), in{2} = 10;
													elseif isnumeric(in{2}) && isequal(in{2}, 1), in{2} = 16;
													elseif isnumeric(in{2}) && isscalar(in{2}) && in{2}<0, in{2} = 0:-in{2}-1;
													end
													x = in{1};
													a = in{2}; if numel(a)==1; b = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'; a=b(1:a); x = upper(x); end
													if ~iscell(x), x = mat2cell(x, ones(size(x,1),1), size(x,2)); end
													y = NaN(numel(x),1);
													for n = 1:numel(x)
													[tf, ind] = ismember(x{n}, a);
													ind = ind(tf);
													y(n) = polyval(ind-1, numel(a));
													end
													out{1} = y; clear tf ind x y
B	1	2	1	2	1	1	1		true	true	true	true	out{1} = logical(dec2bin(in{:})-'0');	convert from decimal to binary. Produces a logical vector	\matlab|logical(dec2bin(...)-'0')|. \sa \matl|YB|
XB	1	1	1		1	1	1		true	true	true	true	if ~iscell(in{1})	convert from binary to decimal	\matlab|bin2dec(char(logical(...)+'0'))|. Works also for cell array input. \sa \matl|ZB|
													out{1} = bin2dec(char(logical(in{1})+'0'));
													else
													out{1} = cellfun(@(x) bin2dec(char(logical(x)+'0')), in{1});
													end
YB	1	2	1	2	1	1	1		true	true	true	true	out{1} = dec2bin(in{:});	convert decimal number to binary string	\matlab|dec2bin|. \sa \matl|B|
ZB	1	1	1		1	1	1		true	true	true	true	out{1} = bin2dec(in{1});	convert binary string to decimal number	\matlab|bin2dec|. \sa \matl|XB|
C
XC
YC	2	4	2		1	1	1		true	true	true	true	if numel(in{2})==1, if size(in{1},1)==1, in{2} = [1 in{2}]; else in{2} = [in{2} 1]; end; end	rearrange array blocks into columns	\matlab+im2col+. If the second input is a scalar \matlab+n+, it is transformed into \matlab+[1 n]+ if the first input is a row vector, or to \matlab+[n 1]+ otherwise. First input can also be a cell array. \sa \matl+ZC+
													if iscell(in{1})
													x = reshape(1:numel(in{1}), size(in{1}));
													y = im2col(x, in{2:end});
													y = in{1}(y);
													out{1} = y; clear x y
													else
													out{1} = im2col(in{:});
													end
ZC	2	3	2		1	1	1		true	true	true	true	if numel(in{2})==1, if size(in{1},1)==1, in{2} = [1 in{2}]; else in{2} = [in{2} 1]; end; end	rearrange distinct array blocks into columns	\matlab+im2col(..., 'distinct')+. If the second input is a scalar n, it is transformed into [1 n] if the first input is a row vector, or to [n 1] otherwise. First input can also be a cell array. \sa \matl+YC+
													in{end+1} = 'distinct';
													if iscell(in{1})
													x = reshape(1:numel(in{1}), size(in{1}));
													y = im2col(x, in{2:end});
													y = in{1}(y);
													out{1} = y; clear x y
													else
													out{1} = im2col(in{:});
													end
D	0	inf	1		0	1	0	1	true	true	true	true	if nout==0	convert to string and display / string representation	(i) With $0$ outputs: If $1$ input: \matlab+disp(num2str(..., '%.15g '))+. If several inputs: \matlab+disp(num2str(eachInput,lastInput))+, where \matlab+eachInput+ loops over all inputs but the last. In either case, (nested) cell arrays are (recursively) unboxed in linear order. Most characters below 32 are replaced by space. (ii) With $1$ output: \matlab+mat2str+. Empty arrays are always shown as \matlab+[]+, \matlab+''+ or \matlab+{}+. Most input characters below 32 are replaced by space. Cell arrays are converted to string representation too. Optional second, third and fourth inputs respectively specify column separator, row separator and whether the separators should be used for non-cell arrays too. Second and third output are converted to char is needed. \sa \matl+XD+, \matl+YD+, \matl+ZD+
													if numel(in)==1, data = in; fmt = {'%.15g '}; else data = in(1:end-1); fmt = in(end); end
													kk = cellfun(@iscell, data);
													while any(kk)
													data(~kk) = num2cell({data{~kk}}); kk = kk(:).';
													for k = find(kk), data{k} = data{k}(:); end
													data = vertcat(data{:}); kk = cellfun(@iscell, data);
													end
													for k = 1:numel(data), d = num2str(data{k}, fmt{:}); d(ismember(d,replaceBySpace)) = ' '; disp(d), end
													clear data kk k d fmt
													else
													if numel(in)<4, sep_noncell = false; else sep_noncell = in{4}; end
													if numel(in)<3, row_sep = '; '; else row_sep = in{3}; end
													if numel(in)<2, col_sep = ' '; else col_sep = in{2}; end
													x = in{1};
													x = {x}; y = {[]}; done = false;
													while ~done
													done = true;
													for n = 1:numel(y);
													if isempty(y{n})
													done = false;
													if ~iscell(x{1})
													if isempty(x{1}), if ischar(x{1}), s = ''''''; else, s = '[]'; end; else, if ischar(x{1}), x{1}(ismember(x{1},replaceBySpace)) = ' '; end; s = mat2str(x{1}); end
													if sep_noncell
													for k = flip(find(~mod(cumsum(s==''''),2) & s==' ')), s = [s(1:k-1) col_sep s(k+1:end)]; end
													for k = flip(find(~mod(cumsum(s==''''),2) & s==';')), s = [s(1:k-1) row_sep s(k+1:end)]; end
													end
													y{n} = s;  x(1) = [];
													else
													str = ['{' repmat([{[]}, col_sep], 1, numel(x{1})) '}'];
													ind_sep = find(cellfun(@(t) isequal(t, col_sep), str));
													if ~isempty(ind_sep)
													str(ind_sep(end)) = [];
													ind_sep(end) = [];
													end
													step_sep = size(x{1}, 2);
													str(ind_sep(step_sep:step_sep:end)) = {row_sep};
													y = [y(1:n-1) str y(n+1:end)]; x = [reshape(x{1}.', 1, []) x(2:end)];
													end
													end
													end
													end
													y = [y{:}];
													out{1} = y;
													clear x sep_noncell row_sep col_sep done s k str inde_sep step_sep y
													end
XD	0	inf	numel(STACK)	1	0	0	0		true	true	true	true	data = in;	convert to string and display	\matlab+disp(num2str(eachInput, '%.15g '))+, where \matlab+eachInput+ loops over all inputs. (Nested) cell arrays are (recursively) unboxed in linear order. Most characters below 32 are replaced by space. \sa \matl+D+, \matl+YD+, \matl+ZD+
													kk = cellfun(@iscell, data);
													while any(kk)
													data(~kk) = num2cell({data{~kk}}); kk = kk(:).';
													for k = find(kk), data{k} = data{k}(:); end
													data = vertcat(data{:}); kk = cellfun(@iscell, data); end
													for k = 1:numel(data), d = num2str(data{k}, '%.15g '); d(ismember(d,replaceBySpace)) = ' '; disp(d), end
													clear data kk k
YD	1	inf	2	1	0	2	1	0	true	true	true	true	if numel(out), [out{:}] = sprintf(in{:});	write formatted data to string	\matlab+sprintf+. If $0$ outputs: prints to screen using \matlab+fprintf(...)+. \sa \matl+D+, \matl+XD+, \matl+ZD+
													else fprintf(in{:}); end
ZD	0	inf	1		0	0	0		true	true	true	true	for k = 1:numel(in), if ischar(in{k}), in{k}(ismember(in{k},replaceBySpace)) = ' '; end, disp(in{k}), end	display	\matlab+disp+ for each input. For char input, most characters below 32 are replaced by space. \sa \matl+D+, \matl+XD+, \matl+YD+
E	1	1	1		1	1	1		true	true	true	true	out{1} = in{1}*2;	multiply by 2	\matlab|(...)*2|
XE	3	3	3		1	1	1		true	true	true	true	if numel(in{3})==1, in{3} = repmat(in{3}, size(in{2})); end	replace elements in numeric or char array	With numeric or char inputs, replace in first input all occurrences of each element of the second input by the corresponding element of the third input. The third input may be longer than the second, and then the extra elements are ignored. Or it may have a single element, and then it is implicitly replicated. Output has the same class and size as the first input. If the three inputs are cell arrays of strings (the second may also be a string instead of a cell array of strings), each string of the first input is considered atomic, that is, replacing is based on whole strings. If the first input is a cell array and the others are numeric or char, replacing is done on each cell's contents as if the cell's contents were the first input
													if ~(iscell(in{1}) && ~iscell(in{2}) && ~iscell(in{3}))
													[ii, jj] = ismember(in{1}, in{2}); y = in{1}; y(ii) = in{3}(jj(ii)); out{1} = y; clear ii jj y
													else
													z = cell(size(in{1}));
													for k = 1:numel(in{1})
													x = in{1}{k};
													[ii, jj] = ismember(x, in{2}); y = x; y(ii) = in{3}(jj(ii)); z{k} = y;
													end
													out{1} = z; clear ii jj x y
													end
YE
ZE
F
XF
YF	1	1	1		1	2	1	2	true	true	true	true	trim = (any(in{1}<0) && (nout==1)) || (~any(in{1}<0) && (nout==2)); in{1} = abs(in{1});	Exponents of prime factor decomposition	(i) With $1$ output: exponents of prime factor decomposition, without skipping primes. If the input is a numeric array it is linearized, and each result is in an output row. If any entry in the input is negative, the absolute value is taken, and the output contains only non-zero exponents. (ii) With $2$ outputs: first output gives the prime factors, second gives the exponents. Primes that are not factors are skipped, as are their zero exponents. If any entry in the input is negative, the absolute value is taken, and all intermediate primes are included, possibly with zero exponents. \sa \matl+Yf+
													f = arrayfun(@factor, in{1}, 'uniformoutput', false);
													p = primes(max([f{:}]));
													y = zeros(numel(f), numel(p));
													for k = 1:numel(f);
													y(k,:) = sum(bsxfun(@eq, f{k}(:), p), 1);
													end
													if nout==1, out{1} = y;
													elseif nout==2, out = {p, y};
													else error('MATL:runtime', 'MATL run-time error: number of outputs not supported');
													end
													if trim, out = cellfun(@(c) c(:, any(y>0, 1)), out, 'UniformOutput', false); end
													clear f p y k trim
ZF
G	0	1	double(numel(CB_G)>1)	0	0	inf	1+(max(numel(CB_G),1)-1)*(numel(in)==0)		true	true	false	true	if numel(CB_G)==0	paste from user-input clipboard G	paste from user-input clipboard G. If $0$ input arguments: addresses all levels. If $1$ input argument: addresses specified level. In either of those cases, if clipboard G has no levels one user-input is implicitly taken to fill the first level
													implInput = input(implicitInputPrompt,'s');
													valid = isempty(regexp(implInput, '^[^'']*(''[^'']*''[^'']*)*[a-df-hk-zA-EG-MOQ-SU-XZ]', 'once')) && isempty(regexp(implInput, '^[^'']*(''[^'']*''[^'']*)*[a-zA-Z]{2}', 'once'));
													assert(valid, 'MATL:runner', 'MATL run-time error: input not allowed')
													if isempty(implInput), implInput = []; else implInput = eval(implInput); end
													CB_G{1} = implInput;
													end
													if numel(in)==0, out = CB_G(1:nout); else out = CB_G(mod(in{1}-1,numel(CB_G))+1); end; clear implInput valid
XG	1	inf	1	2	0	0	0		true	true	true	true	plot(in{:}); if (numel(in)==1 && ~isreal(in{1})) || (numel(in)>1 && ~isreal(in{1}) && ischar(in{2})), axis equal; end; drawnow	plot	\matlab+plot+. Calls \matlab+drawnow+ to update figure immediately. With one input, or with several inputs the second of which is a string: if the first input is complex (even with zero imaginary part), \matlab+axis equal+ is also called.
YG	2	inf	2	3	0	0	0		true	true	true	true	if (isnumeric(in{end}) || islogical(in{end})) && numel(in{end})~=1	display or save image	\matlab+imwrite+, \matlab+imagesc+, \matlab+image+ or \matlab+imshow+. (i) If last input is a scalar: \matlab+0+ corresponds to \matlab+imwrite+, \matlab+1+ to \matlab+imagesc+, \matlab+2+ to \matlab+image+ and \matlab+3+ to \matlab+imshow+. The corresponding function is called with the remaining inputs. (ii) If last input is numeric or logical and not a scalar: \matlab+imshow+ is called with all inputs. (iii) If last input is char: \matlab+imwrite+ is called with all inputs. (i, iii) For \matlab+imwrite+, the first input of type char is interpreted as file name. If it has no extension '.png' is added; if it's empty it is replaced by 'image.png'; and if non existent 'image.png' is used as final input. (i, ii, iii) For \matl+imshow+ and \matl+imwrite+, if the second input is logical it is converted to \matlab+double+. If it is numeric, has the shape of a colormap, and has some entry greater than $1$, it is normalized by converting to \matlab+uint8+, then to \matlab+double+, and then dividing by $255$. For \matlab+imagesc+ and \matlab+image+, the function call is followed by \matlab+axis ij, axis image+. For \matlab+imagesc+, \matlab+image+ and \matlab+imshow+, \matlab+drawnow+ is called to update figure immediately
													if islogical(in{2}), in{2} = double(in{2}); end
													if numel(in)>=2 && isnumeric(in{2}) && ndims(in{2})==2 && size(in{2},2)==3 && any(in{2}(:)>1), in{2} = double(uint8(in{2}))/255; end
													imshow(in{:}); drawnow
													elseif ischar(in{end})
													k = find(cellfun(@ischar, in),1);
													if isempty(in{k}), in{k} = 'image.png'; end;
													if isempty(regexp(in{k}, '\..+$', 'once')), in{k} = [in{k} '.png']; end
													if islogical(in{2}), in{2} = double(in{2}); end
													if numel(in)>=2 && isnumeric(in{2}) && ndims(in{2})==2 && size(in{2},2)==3 && any(in{2}(:)>1), in{2} = double(uint8(in{2}))/255; end
													imwrite(in{:}); clear k
													else
													switch(in{end})
													case 0
													k = find(cellfun(@ischar, in),1);
													if isempty(k)
													in{end+1} = in{end}; in{end-1} = 'image.png';
													else
													if isempty(in{k}), in{k} = 'image.png'; end;
													if isempty(regexp(in{k}, '\..+$', 'once')), in{k} = [in{k} '.png']; end
													end
													if numel(in)>=3 && isnumeric(in{2}) && ndims(in{2})==2 && size(in{2},2)==3 && any(in{2}(:)>1), in{2} = double(uint8(in{2}))/255; end
													imwrite(in{1:end-1}); clear k
													case 1
													imagesc(in{1:end-1}); axis ij, axis image, drawnow
													case 2
													image(in{1:end-1}); axis ij, axis image, drawnow
													case 3
													if numel(in)>=3 && isnumeric(in{2}) && ndims(in{2})==2 && size(in{2},2)==3 && any(in{2}(:)>1), in{2} = double(uint8(in{2}))/255; end
													imshow(in{1:end-1}); drawnow
													otherwise
													error('MATL:runtime', 'MATL run-time error: unrecognized last input');
													end
													end
ZG	1	inf	2	3	0	1	0		true	true	true	true	switch in{end}	control appearance of graphics / format	Depending on numeric last input, calls a graphic function or \matlab+format+ with the remaining inputs.  $0$: \matlab+format+.  $1$: \matlab+axis+. Calls \matlab+drawnow+ to update figure immediately. Flag strings in first to second-last inputs can be replaced by numbers, as follows: 1: \matlab+'equal'+, 2: \matlab+'image'+, 3: \matlab+'square'+, 4: \matlab+'ij'+, 5: \matlab+'xy'+, 6: \matlab+'normal'+, 7: \matlab+'off'+, 8: \matlab+'on'+, 9: \matlab+'tight'+, 10: \matlab+'manual'+, 11: \matlab+'fill'+, 12: \matlab+'auto'+, 13: \matlab+'vis3d'+.  $2$: \matlab+colormap+. If the first input is numeric, has the shape of a colormap, and has some entry greater than $1$, it is normalized by converting to \matlab+uint8+, then to \matlab+double+, and then dividing by $255$. With $0$ outputs, calls \matlab+drawnow+ to update figure immediately.  $3$: \matlab+hold+. Flag strings in first input can be replaced by numbers, as follows: 1: \matlab+'on'+, 2: \matlab+'off'+.
													case 0
													format(in{1:end-1});
													case 1
													str = {'equal' 'image' 'square' 'ij' 'xy' 'normal'  'off' 'on'  'tight' 'manual' 'fill' 'auto' 'vis3d'};
													for k = 1:numel(in)-1, if isnumeric(in{k}), in(k) = str(in{k}); end; end; clear k str
													axis(in{1:end-1}); drawnow
													case 2
													if numel(in)>=2 && isnumeric(in{1}) && ndims(in{1})==2 && size(in{1},2)==3 && any(in{1}(:)>1), in{1} = double(uint8(in{1}))/255; end
													[out{:}] = colormap(in{1:end-1}); if isempty(out), drawnow, end
													case 3
													str = {'on' 'off'};
													if isnumeric(in{1}), in(1) = str(in{1}); end; clear k str
													hold(in{1:end-1})
													otherwise
													error('MATL:runtime', 'MATL run-time error: unrecognized last input');
													end
H	0	0	0		0	inf	numel(CB_H)		true	true	false	true	out = CB_H(1:nout);	paste from clipboard H	paste from clipboard H
XH	0	inf	1	2	0	0	0		false	true	false	true	CB_H = in;	copy to clipboard H	copy to clipboard H
YH
ZH
I	0	0	0		0	inf	numel(CB_I)		true	true	false	true	out = CB_I(1:nout);	paste from clipboard I	paste from clipboard I
XI	0	inf	1		0	0	0		false	true	false	true	CB_I = in;	copy to clipboard I	copy to clipboard I
YI	3	4	3	4	1	1	1		true	true	true	true	str = {'distinct' 'sliding'};	rearrange matrix columns into blocks	\matlab+col2im+. Uses \matlab+'distinct'+ option by default. Second and third inputs may be scalars, and then they are interpreted as numbers of columns. Third input may be a two-vector with product less then the number of elements of first input, and then it is appropriately scaled. This function allows flag strings in fourth input to be replaced by numbers, as follows: 1: \matlab+'distinct'+, 2: \matlab+'sliding'+
													if numel(in)>=4, if isnumeric(in{4}), in(4) = str(in{4}); end; end; clear str
													if numel(in)<4, in{4} = 'distinct'; end
													if isscalar(in{2}), in{2}(2) = size(in{1},1)/in{2}; end
													if isscalar(in{3}), in{3}(2) = numel(in{1})/in{3}; end
													if prod(in{3})~=numel(in{1}), in{3} = round(in{3}*sqrt(numel(in{1})/prod(in{3}))); end
													out{1} = col2im(in{:});
ZI	1	inf	2	3	1	inf	1		true	true	true	true	switch in{end}	image processing functions	Depending on numeric last input, calls an image processing function with the remaining inputs.  $0$: \matlab+imfill+. If first input is logical or numerical it is converted to char.  $1$: \matlab+bwlabeln+.  $2$: \matlab+imdilate+. This function allows second input to be number $4$, $5$, $8$ or $9$, which is interpreted as the corresponding neighbourhood mask.  $3$: \matlab+imerode+. This function allows second input to be number $4$, $5$, $8$ or $9$, which is interpreted as the corresponding neighbourhood mask.
													case 0
													if islogical(in{1}) || ischar(in{1}), in{1} = double(in{1}); end
													[out{:}] = imfill(in{1:end-1});
													case 1
													[out{:}] = bwlabeln(in{1:end-1});
													case 2
													mask = {NaN NaN NaN [false true false; true false true; false true false] [false true false; true true true; false true false] NaN NaN [true true true; true false true; true true true] [true true true; true true true; true true true]};
													if isnumeric(in{2}), in(2) = mask(in{2}); end; clear mask
													[out{:}] = imdilate(in{1:end-1});
													case 3
													mask = {NaN NaN NaN [false true false; true false true; false true false] [false true false; true true true; false true false] NaN NaN [true true true; true false true; true true true] [true true true; true true true; true true true]};
													if isnumeric(in{2}), in(2) = mask(in{2}); end; clear mask
													[out{:}] = imerode(in{1:end-1});
													otherwise
													error('MATL:runtime', 'MATL run-time error: unrecognized last input');
													end
J	0	0	0		0	inf	numel(CB_J)		true	true	false	true	out = CB_J(1:nout);	paste from clipboard J	paste from clipboard J
XJ	0	inf	1		0	0	0		false	true	false	true	CB_J = in;	copy to clipboard J	copy to clipboard J
YJ
ZJ
K	0	0	0		0	inf	numel(CB_K)		true	true	false	true	out = CB_K(1:nout);	paste from clipboard K	paste from clipboard K
XK	0	inf	1		0	0	0		false	true	false	true	CB_K = in;	copy to clipboard K	copy to clipboard K
YK
ZK
L	1	1	1		0	inf	numel(CB_L{in{1}})		true	true	false	true	out = [CB_L{in{1}}(1:nout)];	paste from multi-level clipboard L	paste from multi-level clipboard L. Input specifies level
XL	1	inf	2	3	0	0	0		false	true	false	true	CB_L{in{end}} = in(1:end-1); STACK(end+nin(end)) = [];	copy to multi-level clipboard L	copy to multi-level clipboard L. Topmost input specifies level
YL	1	inf	2	3	1	inf	1		true	true	true	true	str = {'spiral' 'pascal' 'magic' 'hadamard' 'circul' 'gcdmat' 'minij' 'hilb' 'invhilb' 'tridiag' 'ris'};	Higham test matrices and other matrices	\matlab+gallery+ with matrix name as last input. Also includes \matlab+magic+, \matlab+hilb+, \matlab+invhilb+, \matlab+hadamard+, \matlab+pascal+, \matlab+spiral+. This function allows some strings in last input to be replaced by numbers, as follows:  1: \matlab+'spiral'+, 2: \matlab+'pascal'+, 3: \matlab+'magic'+, 4: \matlab+'hadamard'+, 5: \matlab+'circul'+, 6: \matlab+'gcdmat'+, 7: \matlab+'minij'+, 8: \matlab+'hilb'+, 9: \matlab+'invhilb'+, 10: \matlab+'tridiag'+, 11: \matlab+'ris'+
													if isnumeric(in{end}), in(end) = str(in{end}); end; clear str
													switch in{end}
													case {'magic', 'hilb', 'invhilb', 'hadamard', 'pascal', 'spiral'}
													[out{1}] = feval(in{end},in{1:end-1});
													otherwise
													[out{:}] = gallery(in{end}, in{1:end-1});
													end
ZL
M	1	1	1		0	inf	1+(in{1}<=numCbM)*(numel(CB_M{mod(in{1}-1,numCbM)+1})-1)		true	true	false	true	if in{1}>=1 && in{1}<=numCbM	paste from function-input clipboard M	paste from function-input clipboard M. Input specifies level ($1$ to $4$) or individual input ($5$ or larger)
													out = [CB_M{in{1}}(1:nout)];
													elseif in{1}>numCbM
													cbMflip = CB_M(end:-1:1); cbMIndivIn = [cbMflip{cellfun(@numel, cbMflip)>1}]; cbMIndivIn = cbMIndivIn(end:-1:1);
													out = cbMIndivIn(in{1}-numCbM);
													clear cbMflip cbMIndivIn
													else
													error('MATL:runtime', 'MATL run-time error: incorrect input')
													end
XM	1	2	1		1	3	1		true	true	true	true	if ~iscell(in{1})	mode (most frequent value)	\matlab+mode+. First input can be a cell array of strings
													[out{:}] = mode(in{:});
													else
													[x, ~, y] = unique(in{1}(:));
													[out{:}] = mode(y, in{2:end});
													out{1} = x(out{1});
													if nout>=3, out{3} = x([out{3}{:}]); end
													end
YM
ZM
N	0	0	0		1	1	1		true	true	false	true	out{1} = numel(STACK);	number of elements in the stack	number of elements in the stack
XN	2	2	2		1	1	1		true	true	true	true	if numel(in{1})<in{2} || ~(in{2}>0)	all combinations	\matlab+nchoosek+. This interprets first input as an array (even if it is a single number). For inputs \matlab+x+ and \matlab+k+, if \matlab+x+ has less than \matlab+k+ elements or if \matlab+k+ is non-positive the result is an empty array. \sa \matl|Xn|
													out{1} = [];
													else out{1} = nchoosek(in{:});
													end
YN	0	inf	0		1	1	1		true	true	true	true	out{1} = NaN(in{:});	not-a-number	\matlab+NaN+ function. If $0$ inputs: produces literal \matlab+NaN+.
ZN	1	1	1		1	1	1		true	true	true	true	out{1} = isnan(in{:});	true for not-a-number	\matlab+isnan+
O	0	inf	0	2	1	1	1		true	true	true	true	if numel(in)==0, out{1} = 0; else out{1} = zeros(in{:}); end	array of zeros	\matlab+zeros+ (if $0$ inputs: produces output $0$)
XO	1	4	2		1	1	1		true	true	true	true	out{1} = datestr(in{:});	string representation of date	\matlab+datestr+
YO	1	6	1	2	1	1	1		true	true	true	true	if numel(in)==2 && isnumeric(in{2}), str = {'dd-mmm-yyyy HH:MM:SS' 'dd-mmm-yyyy' 'mm/dd/yy' 'mmm' 'm' 'mm' 'mm/dd' 'dd' 'ddd' 'd' 'yyyy' 'yy' 'mmmyy' 'HH:MM:SS' 'HH:MM:SS PM' 'HH:MM' 'HH:MM PM' 'QQ-YY' 'QQ' 'dd/mm' 'dd/mm/yy' 'mmm.dd,yyyy HH:MM:SS' 'mmm.dd,yyyy' 'mm/dd/yyyy' 'dd/mm/yyyy' 'yy/mm/dd' 'yyyy/mm/dd' 'QQ-YYYY' 'mmmyyyy' 'yyyy-mm-dd' 'yyyymmddTHHMMSS' 'yyyy-mm-dd HH:MM:SS'};in(2) = str(in{2}+1); end; clear str	serial date number	\matlab+datenum+. With $2$ inputs, if the second input is numeric it is interpreted as a format specifier as in \matlab+datestr+
													out{1} = datenum(in{:});
ZO	1	3	1	2	1	6	1		true	true	true	true	[out{:}] = datevec(in{:});	date components	\matlab+datevec+
P	1	2	1	2	1	1	1		true	true	true	true	out{1} = flip(in{:});	flip the order of elements	\matlab+flip+. \sa \matl+XP+
XP	1	1	1		1	1	1		true	true	true	true	out{1} = flipud(in{:});	flip array in up-down direction	\matlab+flipud+. \sa \matl+P+
YP	0	0	0		1	1	1		true	true	true	true	out{1} = pi;	pi	\matlab+pi+
ZP	2	5	2	3	1	2	1		true	true	true	true	str = {'cityblock' 'hamming' 'chebychev' 'correlation' 'cosine' 'seuclidean' 'minkowski' 'mahalanobis' 'spearman' 'jaccard' 'euclidean'};	pairwise distances between two sets of points	\matlab+pdist2+. Only predefined distance functions are allowed. This function allows flag strings in the third input to be replaced by numbers, as follows:  1: \matlab+'cityblock'+, 2: \matlab+'hamming'+, 3: \matlab+'chebychev'+, 4: \matlab+'correlation'+, 5: \matlab+'cosine'+, 6: \matlab+'seuclidean'+, 7: \matlab+'minkowski'+, 8: \matlab+'mahalanobis'+, 9: \matlab+'spearman'+, 10: \matlab+'jaccard'+, 11: \matlab+'euclidean'+
													for k = 3:min(numel(in),3), if isnumeric(in{k}), in(k) = str(in{k}); end; end; clear str
													[out{:}] = pdist2(in{:});
Q	1	1	1		1	1	1		true	true	true	true	out{1} = in{1}+1;	increment by 1	\matlab|(...)+1|
XQ	2	6	3		1	1	1		true	true	true	true	str = {'@sum' '@mean' '@(x){sort(x).''}' '@max' '@min' '@prod' '@(x){x.''}' '@(x){x}' '@(x){sort(x)}' '@(x)x(1)' '@(x)x(end)' '@(x){cumsum(x).''}' '@(x){cumprod(x)}' '@nansum' '@nanmean' '@nanmax' '@nanmin' '@(x){cummax(x).''}' '@(x){cummin(x)}' '@(x){cummax(x).''}' '@(x){cummin(x)}'};	construct array by accumulation	\matlab+accumarray+. If first input is \matlab+char+ it is converted to \matlab+double+. The third input may be omitted, and then it is interpreted as \matlab+[]+. Fourth/third argument specifies an anonymous function, as follows:  1: \matlab+'@sum'+, 2: \matlab+'@mean'+, 3: \matlab+'@(x){sort(x).'}'+, 4: \matlab+'@max'+, 5: \matlab+'@min'+, 6: \matlab+'@prod'+, 7: \matlab+'@(x){x.'}'+, 8: \matlab+'@(x){x}'+, 9: \matlab+'@(x){sort(x)}'+, 10: \matlab+'@(x)x(1)'+, 11: \matlab+'@(x)x(end)'+, 12: \matlab+'@(x){cumsum(x).'}'+, 13: \matlab+'@(x){cumprod(x)}'+, 14: \matlab+'@nansum'+, 15: \matlab+'@nanmean'+, 16: \matlab+'@nanmax'+, 17: \matlab+'@nanmin'+, 18: \matlab+'@(x){cummax(x).'}'+, 19: \matlab+'@(x){cummin(x)}'+, 20: \matlab+'@(x){cummax(x).'}'+, 21: \matlab+'@(x){cummin(x)}'+
													if ischar(in{1}), in{1} = double(in{1}); end
													if numel(in)>=3 && isscalar(in{3}), in = [in(1:2) {[]} in(3:end)]; end
													if numel(in)>=4, in{4} = str2func(str{in{4}}); end; clear str
													out{1} = accumarray(in{:});
YQ	1	2	1		1	2	2		true	true	true	true	[out{:}] = rat(in{:});	rational approximation	\matlab+rat+
ZQ	1	4	2	1	1	2	1		true	true	true	true	if numel(in)==1, out{1} = roots(in{1});	polynomial roots / evaluate polynomial / fit polynomial	(i) If $1$ input: \matlab+roots+. (ii) If $2$ inputs: \matlab+polyval+. If $3$ inputs: \matlab+polyfit+. If $4$ inputs: \matlab+inpolygon+
													elseif numel(in)==2, out{1} = polyval(in{:});
													elseif numel(in)==3, out{1} = polyfit(in{:});
													elseif numel(in)==4, [out{:}] = inpolygon(in{:});
													else error('MATL:runtime', 'MATL run-time error: incorrect number of inputs'), end
R	1	2	1	2	1	1	1		true	true	true	true	out{1} = triu(in{:});	upper triangular part	\matlab+triu+. \sa \matl+XR+.
XR	1	2	1	2	1	1	1		true	true	true	true	if numel(in)==1	upper triangular part, above diagonal / build matrix	\matlab+triu(..., 1)+. If $2$ inputs: builds an upper triangular or symmetric matrix from a vector (or from an array in linear order). Second input indicates if the diagonal is filled/not and if the matrix is made symmetric, as follows. 0: don't use diagonal, don't make symmetric. 1: use diagonal, don't make symmetric. 2: don't use diagonal, make symmetric. 3: use diagonal, make symmetric. \sa \matl+R+, \matl+ZR+
													out{1} = triu(in{1},1);
													elseif numel(in)==2 && any(in{2}==[0 2])
													y = triu(ones(round(-1 +sqrt(1+8*numel(in{1})))/2+1),1);
													y(logical(y)) = in{1}(:);
													if in{2}==2, y = y + tril(y.',-1); end
													if ischar(in{1}), y = char(y); end
													out{1} = y; clear y
													elseif numel(in)==2 && any(in{2}==[1 3])
													y = triu(ones(round(-1 +sqrt(1+8*numel(in{1})))/2));
													y(logical(y)) = in{1}(:);
													if in{2}==3, y = y + tril(y.',-1); end
													if ischar(in{1}), y = char(y); end
													out{1} = y; clear y
													end
YR	1	2	1	2	1	1	1		true	true	true	true	out{1} = tril(in{:});	lower triangular part	\matlab+tril+. \sa \matl+ZR+.
ZR	1	2	1	2	1	1	1		true	true	true	true	if numel(in)==1	lower triangular part, below diagonal / build matrix	\matlab+tril(..., -1)+. If $2$ inputs: builds a lower triangular or symmetric matrix from a vector (or from an array in linear order). Second input indicates if the diagonal is filled/not and if the matrix is made symmetric, as follows. 0: don't use diagonal, don't make symmetric. 1: use diagonal, don't make symmetric. 2: don't use diagonal, make symmetric. 3: use diagonal, make symmetric. \sa \matl+XR+, \matl+YR+.
													out{1} = tril(in{1},-1);
													elseif numel(in)==2 && any(in{2}==[0 2])
													y = tril(ones(round(-1 +sqrt(1+8*numel(in{1})))/2+1),-1);
													y(logical(y)) = in{1}(:);
													if in{2}==2, y = y + triu(y.',1); end
													if ischar(in{1}), y = char(y); end
													out{1} = y; clear y
													elseif numel(in)==2 && any(in{2}==[1 3])
													y = tril(ones(round(-1 +sqrt(1+8*numel(in{1})))/2));
													y(logical(y)) = in{1}(:);
													if in{2}==3, y = y + triu(y.',1); end
													if ischar(in{1}), y = char(y); end
													out{1} = y; clear y
													end
S	1	3	1		1	2	1	[false true]	true	true	true	true	if numel(in)>1 && ~ischar(in{2}) && numel(in{2})>1 && isvector(in{2}) && isequal(numel(in{1}),numel(in{2}))	sort	sort an array (\matlab+sort+) / sort an array based on another. (i) Single-array mode works like Matlab's \matlab+sort+. If $2$ inputs, a negative value of the second input corresponds to descending order. If first input is a cell array and the first cell contains a char array, the rest of the cells' contents are converted to char. (ii) If the first input is a cell array and the first cell contains a numeric array, single-array numeric mode is used. The first input is linearized if it's not a vector, and its contents are linearized for the purposes of sorting. The first input is then sorted in lexicographic order, ignoring other inputs. (iii) In two-array mode, this function takes as first $2$ inputs an array and a vector array which is not char. If the first array is not a vector it is linearized. The second vector is sorted and its order is applied to the first. An optional third input specifies direction as a string, or as a negative number in the non-singleton dimension of the second vector. The outputs are the two sorted arrays. (In two-array mode, if the two input arrays are scalar the result is the same as if the second input is interpreted as dimension, corresponding to single array mode). \sa \matl|XS|
													if numel(in)==3 && isnumeric(in{3}) && in{3}<0, in{3}=-in{3}; in{4} = 'descend'; end
													if ~isvector(in{1}), in{1} = in{1}(:); end
													[y2, ind] = sort(in{2:end}); y1 = in{1}(ind); out = {y1, y2}; out = out(1:nout); clear y1 y2
													else
													if numel(in)==2 && in{2}<0, in{2}=-in{2}; in{3} = 'descend'; end
													if iscell(in{1}) && ~ischar(in{1}{1})
													n = max(cellfun(@numel, in));
													x = cellfun(@(t) [t(:).' -inf(1,n-numel(t))], in{1}, 'uniformoutput', 0);
													x = vertcat(x{:});
													[~, y2] = sortrows(x); y1 = in{1}(y2);
													out = {y1, y2}; out = out(1:nout); clear n x y1 y2
													else
													if iscell(in{1}) && ischar(in{1}{1}), in{1} = cellfun(@(c) char(c), in{1}, 'uniformoutput', 0); end
													[out{:}] = sort(in{:});
													end
													end
XS	1	2	1		1	2	1	[false true]	true	true	true	true	[out{:}] = sortrows(in{:});	sort rows	\matlab+sortrows+. \sa \matl|S|
YS	2	3	2	3	1	1	1		true	true	true	true	if numel(in)==3 && numel(in{2})>1 && ndims(in{1})==2 && in{3}<=2	circular shift	\matlab+circshift+. If second input is a scalar and there's no third input, the shift is applied along the first non-singleton dimension. This function also allows first input a 2D array; third input a scalar specifying dimension; and second input a vector or array specifying the shift for each position in the other dimension
													x = in{1};
													if in{3}==2, x = x.'; end
													ind = bsxfun(@plus, 0:size(x,1):numel(x)-1, mod(bsxfun(@plus, (1:size(x,1)).', -in{2}(:).'-1), size(x,1))+1);
													x(:) = x(ind);
													if in{3}==2, x = x.'; end
													out{1} = x; clear x ind
													else
													if numel(in{2})==1 && numel(in)==2
													d = find(size(in{1})>1,1); if isempty(d), d = 1; end
													y = circshift(in{:}, d);
													else
													y = circshift(in{:});
													end
													out{1} = y; clear d y
													end
ZS	1	1	1		1	1	1		true	true	true	true	out{1} = sign(in{:});	sign function	\matlab+sign+
T
XT
YT	1	2	1	2	1	1	1		true	true	true	true	c = any(cellfun(@ischar, in));	Toeplitz matrix	\matlab+toeplitz+. Output is char if any input is
													for k = 1:numel(in); in{k} = double(in{k}); end
													out{1} = toeplitz(in{:});
													if c, out{1} = char(out{1}); end
													clear c k
ZT
U	1	1	1		1	2	1		true	true	true	true	if isnumeric(in{1})	convert char matrix to numeric or to general array / square	(i) For char input: \matlab+str2num+ with content checking. Most characters below 32 are replaced by space (as in \matl+D+). The input content is then checked. If it fails, \matlab+[]+ is returned. Else \matlab+str2num+ is applied. If that fails, the input string is evaluated. If that also fails, \matlab+[]+ is returned. The second output is supported in all cases. (ii) For numeric input: \matlab+(...).^2+
													out{1} = in{1}.^2;
													else
													in{1}(ismember(in{1},replaceBySpace)) = ' ';
													valid = true;
													for r = 1:size(in{1},1)
													valid = valid && isempty(regexp(in{1}(r,:), '^[^'']*(''[^'']*''[^'']*)*[a-df-hk-zA-EG-MOQ-SU-XZ]', 'once')) && isempty(regexp(in{1}(r,:), '^[^'']*(''[^'']*''[^'']*)*[a-zA-Z]{2}', 'once'));
													end
													if valid
													[y, ok] = str2num(in{1});
													if ~ok && size(in{1},1)==1
													try y = eval(in{1}); ok = true; catch, y = []; ok = false; end
													end
													else
													y = []; ok = false;
													end
													out{1} = y; if nout>1, out{2} = ok; end; clear ok r valid
													end
XU	1	1	1		1	1	1		true	true	true	true	out{1} = str2double(in{:});	convert string to double precision value	\matlab+str2double+
YU
ZU
V	1	2	1	2	1	1	1		true	true	true	true	if numel(in)<2, in{2} = '%.15g '; end	convert numbers to a string	\matlab+num2str+. Uses format \matlab+'%.15g '+ by default. To get Matlab's default format use \matlab+[]+ as format specification
													if numel(in)==2 && isempty(in{2}), in(2) = []; end
													out{1} = num2str(in{:});
XV
YV
ZV
W	1	1	1		1	1	1		true	true	true	true	out{1} = 2.^in{1};	2 raised to array, element-wise	\matlab+2.^(...)+. Array power (or rather exponentiation) with base $2$
XW
YW
ZW
X
XX	2	9	2	3	1	6	max(1,sum(ismember(cellfun(@num2str, in(3:end), 'uniformoutput', false), {'start' 'end' 'tokenExtents' 'match' 'tokens' 'split' '1' '2' '3' '5' '6' '7'})))		true	true	true	true	str = {'start' 'split' 'end' 'once' 'tokenExtents' 'tokens' 'match'};	match regular expression	\matlab+regexp+. With $2$ inputs and $1$ output: \matlab+regexp(..., ..., 'match')+. If first or second inputs are numeric they are converted to char. If they are numeric or char arrays they are linearized into a row. If they are cells their contents are converted to char. \matlab+'names'+ output is not supported. This function allows flag strings in third and subsequent inputs to be replaced by numbers, as follows: 1: \matlab+'start'+, 2: \matlab+'split'+, 3: \matlab+'end'+, 4: \matlab+'once'+, 5: \matlab+'tokenExtents'+, 6: \matlab+'tokens'+, 7: \matlab+'match'+
													for k = 3:numel(in), if isnumeric(in{k}), in(k) = str(in{k}); end; end; clear str
													if numel(in)==2 && nout==1, in{3} = 'match'; end
													if isnumeric(in{1}), in{1}=char(in{1}); end; if isnumeric(in{2}), in{2}=char(in{2}); end
													if size(in{1},1)>1, in{1} = in{1}(:).'; end; if size(in{2},1)>1, in{2} = in{2}(:).'; end
													if iscell(in{1}), in{1} = cellfun(@char, in{1}, 'UniformOutput', false); end; if iscell(in{2}), in{2} = cellfun(@char, in{2}, 'UniformOutput', false); end;
													if nout==6, skipNames = true; else skipNames = false; end
													y = cell(1,nout+skipNames); [y{:}] = regexp(in{:});
													if skipNames, out = y([1:5 7]); else out = y; end
													clear y skipNames k
YX	3	5	3	4	1	1	1		true	true	true	true	if isnumeric(in{1}), in{1}=char(in{1}); end; if isnumeric(in{2}), in{2}=char(in{2}); end; if isnumeric(in{3}), in{3}=char(in{3}); end	replace string using regular expression	\matlab+regexprep+. If first, second or third inputs are numeric they are converted to char. If they are numeric or char arrays they are linearized into a row. If they are cells their contents are converted to char
													if size(in{1},1)>1, in{1} = in{1}(:).'; end; if size(in{2},1)>1, in{2} = in{2}(:).'; end; if size(in{3},1)>1, in{3} = in{3}(:).'; end;
													if iscell(in{1}), in{1} = cellfun(@char, in{1}, 'UniformOutput', false); end; if iscell(in{2}), in{2} = cellfun(@char, in{2}, 'UniformOutput', false); end; if iscell(in{3}), in{3} = cellfun(@char, in{3}, 'UniformOutput', false); end
													[out{:}] = regexprep(in{:});
ZX
Y
XY
YY	0	inf	0		1	1	1		true	true	true	true	out{1} = inf(in{:});	infinity	\matlab+inf+ function. If $0$ inputs: produces literal \matlab+inf+.
ZY	1	1	1		1	1	1		true	true	true	true	out{1} = isinf(in{:});	true for infinite elements	\matlab+isinf+
Z
XZ
YZ
ZZ
[
X[	2	2	2		1	inf	numel(in{1})		true	true	true	true	siz = double(in{1}); ndx = in{2}; lensiz = length(siz);	convert linear index into subscripts	\matlab+ind2sub+ without input restrictions
													if lensiz < nout
													siz = [siz ones(1,nout-lensiz)];
													elseif lensiz > nout
													siz = [siz(1:nout-1) prod(siz(nout:end))];
													end
													vout = {};
													if nout > 2
													k = cumprod(siz);
													for i = nout:-1:3,
													vi = rem(ndx-1, k(i-1)) + 1;
													vj = (ndx - vi)/k(i-1) + 1;
													vout{i-2} = double(vj);
													ndx = vi;
													end
													end
													if nout >= 2
													vi = rem(ndx-1, siz(1)) + 1;
													v2 = double((ndx - vi)/siz(1) + 1);
													v1 = double(vi);
													out = [{v1 v2} vout];
													else 
													v1 = double(ndx);
													out = [{v1} vout];
													end
													out = out(1:nout); clear siz ndx lensiz k i vi vj vout v1 v2
% This code above was adapted from Matlab's `ind2sub`
Y[
Z[
\	2	2	2		1	2	1	2	true	true	true	true	out{1} = bsxfun(@mod, in{1}, in{2});	modulo/quotient after division (element-wise, singleton expansion)	\matlab+mod+, element-wise with singleton expansion. With $2$ outputs: second output is \matlab+floor(.../...)+. \sa \matl|X\|, \matl|o|
													if numel(out)==2, out{2} = floor(bsxfun(@rdivide, in{1}, in{2})); end
X\	2	2	2		1	1	1		true	true	true	true	out{1} = bsxfun(@mod, in{1}-1, in{2})+1;	modulo on the interval [1,divisor+1) (element-wise, singleton expansion)	\matlab|mod(...-1, ...)+1|, element-wise with singleton expansion. \sa \matl|\|
Y\	2	2	2		1	1	1		true	true	true	true	out{1} = in{1}\in{2};	left matrix division	left matrix division, \matlab+\+ (\matlab+mldivide+)
Z\	1	1	1		1	1	1		true	true	true	true	if numel(in{1})>1, error('MATL:runtime', 'MATL run-time error: too many inputs'); end	divisors	divisors of a number. For negative input the absolute value is used
													if in{1}<0, in{1} = -in{1}; end; out{1} = find(~mod(in{1}, 1:in{1}));
]
X]	3	inf	3		1	1	1		true	true	true	true	cp = cumprod(in{1}(1:end-1));	convert subscripts into linear index	\matlab+sub2ind+ without input restrictions
													y = in{2};
													for n = 3:numel(in)
													y = y + cp(n-2)*(in{n}-1);
													end
													out{1} = y; clear cp y
Y]
Z]
^	2	2	2		1	1	1		true	true	true	true	out{1} = bsxfun(@power, in{1}, in{2});	array power (element-wise, singleton expansion)	\matlab+.^+ (\matlab+power+), element-wise with singleton expansion
X^	1	1	1		1	1	1		true	true	true	true	out{1} = sqrt(in{:});	square root	\matlab+sqrt+
Y^	2	2	2		1	1	1		true	true	true	true	if islogical(in{1}), in{1} = double(in{1}); end	matrix power	\matlab+^+ (\matlab+mpower+)
													if islogical(in{2}), in{2} = double(in{2}); end
													out{1} = in{1}^in{2};
Z^	2	2	2		1	1	1		true	true	true	true	if numel(in{1})==1 && numel(in{2})>1, in([1 2]) = in([2 1]); end	Cartesian power	(i) Given an array and a number $n$, computes the Cartesian power of the array times itself $n$ times. (ii) If the first input is a number and the second input is an array of at least two elements, the inputs are interpreted in reverse order. When using this mode, caution is needed in case the second input (array) may become a scalar, because then mode (i) will be used. \sa \matl+Z*+
													n = in{2}; combs = cell(1,n);
													[combs{end:-1:1}] = ndgrid(in{1});
													combs = cat(n+1, combs{:}); combs = reshape(combs,[],n);
													out{1} = combs; clear combs n
_	1	1	1		1	1	1		true	true	true	true	if isa(in{1}, 'uint8'), out{1} = double(in{1})/255;	unary minus / normalize uint8 values	(i) If input is \matlab+uint8+: unary \matlab+-+ (\matlab+uminus+), that is, output is the negative of the input. (ii) If input is \matlab+uint8+: converts to \matlab+double+ and divides by $255$
													else out{1} = -in{1}; end
X_
Y_
Z_
`
X`
Y`	0	0	0		0	1	0		true	true	true	true	if numel(out)==1, out{1} = tic; else tic; end	start a stopwatch timer	\matlab+tic+. \sa \matl+Z`+
Z`	0	1	0		0	1	1		true	true	true	true	if numel(in) && numel(out)==1, out{1} = toc(in{:});	read the stopwatch timer	\matlab+toc+. \sa \matl+Y`+
													elseif numel(in) && numel(out)==0, toc(in{:});
													elseif ~numel(in) && numel(out)==1, out{1} = toc;
													elseif ~numel(in) && numel(out)==0, toc; end
% Matlab R2015b hangs with tic; in = {}; t=toc(in{:}). That's why I distinguish here the no-input version
a	1	2	1	2	1	1	1		true	true	true	true	out{1} = any(in{:});	any	\matlab+any+. \sa \matl|Xa|
Xa	1	1	1		1	1	1		true	true	true	true	out{1} = any(in{:},1);	any, along first dimension	\matlab+any(..., 1)+. \sa \matl|a|
Ya	2	4	2	3	1	1	1		true	true	true	true	if ~any(imag(in{2})) && ~any(in{2}<0)	pad / unpad array	(i) \matlab+padarray+. It allows the first input to be \matlab+char+; and then the output is also \matlab+char+. If the second input is \matlab+logical+ or the pad value is \matlab+char+ they are converted to \matlab+double+. This function allows flag strings in fourth input to be replaced by numbers, as follows: 1: \matlab+'pre'+, 2: \matlab+'post'+, 3: \matlab+'both'+. (ii) If the second input contains at least one negative or complex value, the array in the first input is unpadded. The array can only have two dimensions. The second input can have one or two entries, specifying dimensions. A negative value indicates unpad along that dimension. A complex value indicates unpad along the two dimensions. The third input specifies which values are considered padding; by default $0$
													c = ischar(in{1}); if c, in{1} = double(in{1}); end
													if numel(in)>=3 && ischar(in{3}) && numel(in{3})==1, in{3} = double(in{3}); end
													if islogical(in{2}), in{2} = double(in{2}); end
													str = {'pre' 'post' 'both'};
													for k = 4:min(numel(in),4), if isnumeric(in{k}), in(k) = str(in{k}); end; end; clear k str
													out{1} = padarray(in{:});
													if c, out{1} = char(out{1}); end; clear c
													else
													if any(imag(in{2})), in{2} = [-1 -1]; end
													if numel(in{2})==1, in{2}(end+1) = 0; end
													if numel(in)<3, in{3} = 0; end
													if in{2}(1)<0
													s = find(~all(ismember(in{1}, in{3}),2), 1, 'first');
													e = find(~all(ismember(in{1}, in{3}),2), 1, 'last');
													in{1} = in{1}(s:e,:);
													end
													if in{2}(2)<0
													s = find(~all(ismember(in{1}, in{3}),1), 1, 'first');
													e = find(~all(ismember(in{1}, in{3}),1), 1, 'last');
													in{1} = in{1}(:,s:e); clear s e
													end
													out{1} = in{1};
													end
Za	3	4	3	4	1	1	1		true	true	true	true	if ~iscell(in{1}), in{1} = mat2cell(in{1}, ones(1,size(in{1},1)), size(in{1},2)); else in{1} = in{1}(:); end	Convert numbers between bases	Converts the number represented by input 1 from the base specified by input 2 to that of input 3. Each base can be a number or a vector. In the first case the alphabet is from 0 to that number minus 1. If the second or third input equals \matl+T+ or \matl+F+, it is respectively interpreted as \matlab+' ':'~'+ (all printable ASCII chars) or \matlab+[' ':'&' '(':'~']+ (all printable ASCII chars except single quote). Non-valid digits in the first input are discarded. An optional fourth input indicates number of digits of the result. First input can be a matrix or a cell array; and then the result is a matrix in which each row corresponds to a row of the input matrix, or to a cell of the input cell array in linear order. \sa \matl+YA+, \matl+ZA+
													if ~iscell(in{1}), in{1} = mat2cell(in{1}, ones(1,size(in{1},1)), size(in{1},2)); else in{1} = in{1}(:); end
													if islogical(in{2}) && isscalar(in{2})
													if in{2}, in{2} = ' ':'~'; else in{2} = [' ':'&' '(':'~']; end
													end
													if islogical(in{3}) && isscalar(in{3})
													if in{3}, in{3} = ' ':'~'; else in{3} = [' ':'&' '(':'~']; end
													end
													if numel(in{2})>1, ax = in{2}; bx=numel(ax); else bx = in{2}; ax = 0:bx-1; end
													if numel(in{3})>1, az = in{3}; bz=numel(az); else bz = in{3}; az = 0:bz-1; end
													Z = cell(size(in{1}));
													for c = 1:numel(in{1})
													x = in{1}{c}; [valid, x] = ismember(x,ax); x = x(valid)-1;
													if ~isempty(x)
													z = NaN(1,ceil(numel(x)*log2(bx)/log2(bz))); done_outer = false;
													n = 0;
													while ~done_outer
													n = n +1;
													x = [0 x(find(x,1):end)];
													y = NaN(size(x)); done_inner = false;
													m = 0;
													while ~done_inner
													m = m + 1;
													t = x(1)*bx+x(2);
													r = mod(t, bz); q = (t-r)/bz;
													y(m) = q; x = [r x(3:end)];
													done_inner = numel(x) < 2;
													end
													y = y(1:m);
													z(n) = r; x = y; done_outer = ~any(x);
													end
													z = z(n:-1:1);
													if numel(in)>=4 && numel(z)<in{4}, z = [zeros(1,in{4}-numel(z)) z]; end
													Z{c} = z;
													end
													end
													L = max(cellfun(@numel, Z));
													Z = cellfun(@(x) [zeros(1, L-numel(x)) x], Z, 'uniformoutput', false);
													Z = vertcat(Z{:});
													Z = az(Z+1);
													out{1} = Z; clear x ax bx z Z az bz y t r q k m n c done_outer done_inner valid L
b	0	inf	3	4	0	0	0		false	true	false	true	if ~isempty(in), in = in([2:end 1]); STACK(end+nin) = in; end	bubble up element in stack	bubble up element in stack
Xb
Yb	1	inf	1	2	1	2	1		true	true	true	true	if isnumeric(in{1})	split string or numeric array at delimiter	(i) \matlab+strsplit+. If second input is numeric it is converted to char. This function allows flag strings in third, fifth etc inputs to be replaced by numbers, as follows: 1: \matlab+'CollapseDelimiters'+, 2: \matlab+'DelimiterType'+, 3: \matlab+'RegularExpression'+, 4: \matlab+'Simple'+. (ii) First input can be a cell array of strings, and then the result is a cell array of cell arrays of strings. Only one output is supported in this mode. (iii) First input can be numeric. In this mode only one output is supported, the default delimiter is 0, and the parameter \matlab+'CollapseDelimiters'+ can be used. The second input (delimiter) can be a single number or a numeric array, and in the latter case each element is a possible delimiter. If the first input is a row array the output will contain row arrays; otherwise it will contain column arrays
													if numel(in)==1, in{2} = 0; end
													collapse = true; c = find(strcmp(in(3:end), 'CollapseDelimiters')); if ~isempty(c), collapse = in{c+3}; end
													isRow = isrow(in{1}); x = in{1}(:); d = in{2};
													ind = any(bsxfun(@eq, [d(1); x; d(1)], d(:).'), 2);
													x(ind(2:end-1)) = [];
													if isRow, x = x.'; y = mat2cell(x, 1, diff(find(ind))-1);
													else, y = mat2cell(x, diff(find(ind))-1, 1);
													end
													if collapse
													e = ~cellfun(@isempty, y); e(1) = true; e(end) = true;
													y = y(e);
													end
													out{1} = y;
													clear x y collapse d ind e
													else
													str = {'CollapseDelimiters' 'DelimiterType' 'RegularExpression' 'Simple'};
													for k = 3:2:numel(in), if isnumeric(in{k}), in(k) = str(in{k}); end; end; clear str
													if numel(in)>1 && isnumeric(in{2}), in{2} = char(in{2}); end;
													if ~iscell(in{1})
													[out{:}] = strsplit(in{:});
													elseif nout==1
													out{1} = cellfun(@(x) strsplit(x, in{2:end}), in{1}, 'UniformOutput', false);
													else
													error('MATL:runtime', 'MATL run-time error: only one output is supported with cell array input');
													end
													end
Zb
c	1	inf	1		1	1	1		true	true	true	true	if ~iscell(in{1})	convert to character array	\matlab+char+. Sparse input is first converted to full, and logical input is first converted to double. For cell array input, non-char cell contents are first converted to char
													if issparse(in{1}), in{1} = full(in{1}); end
													if islogical(in{1}), in{1} = double(in{1}); end
													out{1} = char(in{:});
													else
													for k = 1:numel(in{1}), if ~ischar(in{1}{k}), in{1}{k} = char(in{1}{k}); end; end
													out{1} = char(in{:});
													end
Xc	3	inf	3	numel(STACK)	1	1	1		true	true	true	true	if any(cellfun(@ischar, in))	concatenate arrays	\matlab+cat+. The dimension is the last input
													for k = 1:numel(in)
													if islogical(in{k}), in{k} = double(in{k}); end
													end
													end
													out{1} = cat(in{end}, in{1:end-1}); clear k
Yc	1	inf	2	numel(STACK)	1	1	1		true	true	true	true	if all(cellfun(@isnumeric, in) | cellfun(@islogical, in))	concatenate strings	\matlab+strcat+. If not all inputs are numerical or logical, numerical or logical inputs are converted to char. If all inputs are numerical or logical the result is numerical or logical (with singleton expansion along the first dimension), and no trailing values are removed 
													m = max(cellfun(@(x) size(x,1), in));
													for k = 1:numel(in), if size(in{k},1)==1, in{k} = repmat(in{k},m,1); end; end
													out{1} = horzcat(in{:}); clear m k
													else
													for k = 1:numel(in), if isnumeric(in{k}), in{k} = char(in{k}); end; if islogical(in{k}), in{k} = char(double(in{k})); end; end;
													out{1} = strcat(in{:}); clear k
													end
Zc	1	2	1	2	1	1	1		true	true	true	true	if ischar(in{1}{1})	join cell array of strings or numbers into single vector	\matlab+strjoin+. This function also allows input with numeric content. The first cell of the first input determines char or numeric mode. If that cell contains a char (resp. numeric) array, numeric (resp. char) contents in other cells, as well as the second input or its contents, are converted to char (resp. double). (i) Char mode corresponds to \matlab+strjoin+. (ii) Numeric mode is similar: it has a default delimiter, which is 0; or a single delimiter may be specified, which may be a scalar or an array; or a cell array of delimiters may be used. (i, ii) Both in char and in numeric mode, non-vector arrays are linearized, and the result is a row vector. Surplus delimiters are ignored
													in{1} = in{1}(:).';
% This line is for compatibility with R2014b `strjoin`: it doesn't like cell arrays that are not rows
													for k = 1:numel(in{1}), if isnumeric(in{1}{k}), in{1}{k} = char(in{1}{k}); end;
													in{1}{k} = in{1}{k}(:).'; end;
													if numel(in)>1 && isnumeric(in{2}), in{2} = char(in{2}); end;
													if numel(in)>1 && iscell(in{2}), in{2} = in{2}(1:numel(in{1})-1);
													for k = 1:numel(in{2}), in{2}{k} = in{2}{k}(:).'; if isnumeric(in{2}{k}), in{2}{k} = char(in{2}{k}); end; end
													end
													out{1} = strjoin(in{:});
													else
													for k = 1:numel(in{1}), if ischar(in{1}{k}), in{1}{k} = double(in{1}{k}); end;
													end;
													if numel(in)==1, in{2} = 0; end
													if ischar(in{2}), in{2} = double(in{2}); end;
													singledelim = ~iscell(in{2});
													if singledelim, delim = in{2}(:).'; if ischar(in{2}), in{2} = double(in{2}); end
													else, for k = 1:numel(in{2}), in{2}{k} = in{2}{k}(:).'; if ischar(in{2}{k}), in{2}{k} = double(in{2}{k}); end; end
													end
													y = in{1}{1}(:).';
													for k = 2:numel(in{1})
													if ~singledelim, delim = in{2}{k-1}; end
													y = [y delim in{1}{k}(:).'];
													end
													out{1} = y; clear y singledelim delim
													end
d	1	3	1	2	1	1	1		true	true	true	true	if numel(in)==1, out{1} = diff(in{1});	difference	\matlab+diff+ with second and third input interchanged: second specifies dimension, third specifies difference order.
													elseif numel(in)==2, out{1} = diff(in{1}, [], in{2});
													elseif numel(in)==3, out{1} = diff(in{[1 3 2]});
													else error('MATL:runtime', 'MATL run-time error: incorrect number of inputs'), end
Xd	1	4	1	2	1	2	1		true	true	true	true	if numel(in)==2 && numel(out)==1 && islogical(in{2}) && isscalar(in{2}) && in{2}, in{2} = -size(in{1},1)+1:size(in{1},2)-1; end	diagonal matrices and diagonals of a matrix	If $1$ input and $1$ output: \matlab+diag+. Otherwise: \matlab+spdiags+, with char inputs automatically converted to \matlab+double+. With $2$ inputs and $1$ output, if the second input is \matlab+true+ it selects all diagonals from the first input
													if numel(in)==1 && numel(out)==1, out{1} = diag(in{:});
													elseif numel(in)==2 && numel(out)==1 && isrow(in{1})
													y = zeros(size(in{2})); mask = (in{2}>=0) & (in{2}<=numel(in{1})-1);  y(mask) = in{1}(in{2}(mask)+1); out{1} = y; clear y
													elseif numel(in)==2 && numel(out)==1 && iscolumn(in{1})
													y = zeros(size(in{2})); mask = (in{2}<=0) & (in{2}>=1-numel(in{1}));  y(mask) = in{1}(1-in{2}(mask)); out{1} = y; clear y
													elseif numel(in)==1 && numel(out)==2 && isrow(in{1})
													y = nonzeros(in{1}).'; z = find(in{1})-1; out = {y z}; clear y z
													elseif numel(in)==1 && numel(out)==2 && iscolumn(in{1})
													y = flip(nonzeros(in{1}).'); z = flip(1-find(in{1})); out = {y z}; clear y z
													else
													for k = 1:numel(in), if ischar(in{k}), in{k} = double(in{k}); end; end
													[out{:}] = spdiags(in{:}); clear k
													end
Yd	1	inf	2	numel(STACK)	1	1	1		true	true	true	true	out{1} = blkdiag(in{:});	block diagonal concatenation	\matlab+blkdiag+
Zd	1	2	2	1	1	3	1		true	true	true	true	if numel(in)==1 && numel(out)==1, x=in{1}(1); for t=in{1}(:).', x=gcd(x,t); end; out{1}=x;	greatest common divisor (element-wise, singleton expansion)	\matlab+gcd+, element-wise with singleton expansion. With $1$ input and $1$ output, computes the greatest common divisor of all elements of the input
													else
													if max(size(in{1}))==1 || max(size(in{2}))==1 || isequal(size(in{1}), size(in{2}))
													[out{:}] = gcd(in{:});
													else
													nd = max(ndims(in{1}), ndims(in{2})); sz1 = arrayfun(@(n)size(in{1},n), 1:nd); sz2 = arrayfun(@(n)size(in{2},n), 1:nd);
													assert(all(sz1==sz2 | sz1==1 | sz2==1), 'MATL:runtime', 'MATL run-time error: inputs have incompatible sizes')
													rm1 = ones(1,nd); rm1(sz1==1) = sz2(sz1==1); rm2 = ones(1,nd); rm2(sz2==1) = sz1(sz2==1);
													insx1 = repmat(in{1}, rm1); insx2 = repmat(in{2}, rm2); [out{:}] = gcd(insx1, insx2);
													clear nd sz1 sz2 rm1 rm2 insx1 insx2
													end
													end
e	1	inf	2	1	1	1	1		true	true	true	true	if numel(in)>1	reshape array / remove singleton dimensions	(i) With $1$ input: \matlab+squeeze+. (ii) With more than $1$ input: \matlab+reshape+. If second input is logical, contiguous equal values indicate dimensions that will be collapsed; and a final \matlab+[]+ is implicit. If second input is a (non-logical) scalar, a final \matlab+[]+ is implicit. If size specification doesn't contain \matlab+[]+ (explicit or implicit), the first input is padded or truncated if needed; padding is done with \matlab+0+, \matlab+false+, \matlab+char(0)+ or \matlab+{[]}+ according to type of first input. If size specification contains \matlab+[]+ (explicit or implicit), the first input is padded if needed
													if islogical(in{2})
													nd = {size(in{1},1)};
													v = in{2}(1);
													for k = 2:numel(in{2});
													if in{2}(k)==v
													nd{end} = nd{end}*size(in{1},k);
													else
													nd{end+1} = size(in{1},k);
													v = in{2}(k);
													end
													end
													nd{end+1} = [];
													out{1} = reshape(in{1}, nd{:});
													else
													if numel(in)==2 && isscalar(in{2}), in{3} = []; end
													if ~any(cellfun(@isempty, in(2:end))) && prod([in{2:end}])>numel(in{1})
													if isnumeric(in{1}), in{1} = in{1}(:); in{1}(end+1:prod([in{2:end}])) = 0;
													elseif islogical(in{1}), in{1} = in{1}(:); in{1}(end+1:prod([in{2:end}])) = false;
													elseif ischar(in{1}), in{1} = in{1}(:); in{1}(prod([in{2:end}])) = char(0);
													elseif iscell(in{1}), in{1} = in{1}(:); in{1}(prod([in{2:end}])) = {[]};
													else error('MATL:runtime', 'MATL run-time error: unrecognized type of first input');
													end, end
													if ~any(cellfun(@isempty, in(2:end))) && prod([in{2:end}])<numel(in{1})
													if isnumeric(in{1}), in{1} = in{1}(1:prod([in{2:end}]));
													elseif islogical(in{1}), in{1} = in{1}(1:prod([in{2:end}]));
													elseif ischar(in{1}), in{1} = in{1}(1:prod([in{2:end}]));
													elseif iscell(in{1}), in{1} = in{1}(1:prod([in{2:end}]));
													else error('MATL:runtime', 'MATL run-time error: unrecognized type of first input');
													end, end
													if any(cellfun(@isempty, in(2:end))) && mod(numel(in{1}),prod([in{2:end}]))
													if isnumeric(in{1}), in{1} = in{1}(:); in{1}(end+1:end+prod([in{2:end}])-mod(numel(in{1}),prod([in{2:end}]))) = 0;
													elseif islogical(in{1}), in{1} = in{1}(:); in{1}(end+1:end+prod([in{2:end}])-mod(numel(in{1}),prod([in{2:end}]))) = false;
													elseif ischar(in{1}), in{1} = in{1}(:); in{1}(end+1:end+prod([in{2:end}])-mod(numel(in{1}),prod([in{2:end}]))) = char(0);
													elseif iscell(in{1}), in{1} = in{1}(:); in{1}(end+1:end+prod([in{2:end}])-mod(numel(in{1}),prod([in{2:end}]))) = {[]};
													else error('MATL:runtime', 'MATL run-time error: unrecognized type of first input');
													end, end
													out{1} = reshape(in{:});
													end
													else
													out{1} = squeeze(in{:});
													end
Xe
Ye
Ze	1	1	1		1	1	1		true	true	true	true	out{1} = exp(in{:});	exponential	\matlab+exp+
f	1	3	1		1	3	1	2	true	true	true	true	[out{:}] = find(in{:});	find	\matlab+find+
Xf	1	4	2	1	1	1	1		true	true	true	true	if numel(in)>1	find one string within another / non-empty substrings	(i) If 2 or more inputs: \matlab+strfind+. Works also when the first input is a numeric array or a cell array of numeric arrays. In this case each numeric array is linearized, and results are row vectors. (ii) If 1 input: output is a cell array of all non-empty substrings. Works also for numeric or cell arrays
													if ischar(in{1}) || (iscell(in{1})&&ischar(in{1}{1}))
													out{1} = strfind(in{:});
													else
													if ~iscell(in{1})
													t = in{1}(:); p = in{2}(:); n = numel(p);
													y = [];
													for k = 1:numel(t)-n+1
													if t(k:k+n-1)==p, y = [y k]; end
													end
													if numel(in)>2 && strcmp(in{3},'ForceCellOutput') && in{4}, y = {y}; end
													else
													y = cell(size(in{1}));
													for c = 1:numel(in{1})
													t = in{1}{c}(:); p = in{2}(:); n = numel(p);
													y{c} = [];
													for k = 1:numel(t)-n+1
													if t(k:k+n-1)==p, y{c} = [y{c} k]; end
													end
													end
													end
													out{1} = y; clear y t c p k
													end
													else
													y = cell(1,numel(in{1})*(numel(in{1})+1)/2);k = 0;
													for s = 1:numel(in{1})
													for e = s:numel(in{1})
													k = k+1; y{k} = in{1}(s:e);
													end
													end
													out{1} = y; clear y s e
													end
Yf	1	1	1		1	1	1		true	true	true	true	if in{1}>=0, if in{1}==1, out{1} = []; else out{1} = factor(in{1}); end	prime factors	\matlab+factor+. For input $1$ it returns an empty array, not $1$ like \matlab+factor+ does. For negative input, \matlab+factor+ is applied to the absolute value of the input (so input $-1$ produces $1$). \sa \matl+YF+
													else in{1}=-in{1};
													out{1} = factor(in{1});
													end
Zf
g	1	1	1		1	1	1		true	true	true	true	if ~iscell(in{1}), if ~isreal(in{1}), in{1} = abs(in{1}); end, out{1} = logical(in{1});	convert to logical, or from cell array to single array	(i) For non-cell input: \matlab+logical+. Works also for complex numbers, using their absolute value. (ii) For cell input: \matlab+cell2mat+
													else, out{1} = cell2mat(in{:}); end
Xg	1	inf	2		1	inf	numel(in)		true	true	true	true	[out{:}] = ndgrid(in{:});	rectangular grid in N-D space	\matlab+ndgrid+
Yg	1	3	1		1	1	1		true	true	true	true	if numel(in)==1, out{1} = gamma(in{1});	gamma, incomplete gamma or incomplete beta function	\matlab+gamma+ / \matlab+gammainc+ / \matlab+betainc+, depending on number of inputs
													elseif numel(in)==2, out{1} = gammainc(in{:});
													else out{1} = betainc(in{:}); end
Zg	1	2	1	2	1	1	1		true	true	true	true	if numel(in)==1, out{1} = gammaln(in{1});	logarithm of gamma or beta function	\matlab+gammaln+ / \matlab+betaln+, depending on number of inputs
													else out{1} = betaln(in{:}); end
h	0	inf	2	numel(STACK)	1	1	1		true	true	true	true	if any(diff(nonzeros(cellfun(@(x) size(x,1), in))))	horizontal concatenation	\matlab+horzcat+. If inputs are matrices with non-matching sizes they are linearized
													in = cellfun(@(x) reshape(x,1,[]), in, 'uniformoutput', false);
													end
													if any(cellfun(@ischar, in))
													for k = 1:numel(in)
													if islogical(in{k}), in{k} = double(in{k}); end
													end
													end
													out{1} = horzcat(in{:}); clear k
Xh	0	inf	numel(STACK)	2	1	1	1		true	true	true	true	out{1} = in;	concatenate into cell array	concatenate into cell array (\matlab+{..., ...}+)
Yh	1	2	2	1	1	1	1		true	true	true	true	y = hankel(in{:}); if any(cellfun(@ischar,in)), y = char(y); end; out{1} = y; clear y	Hankel matrix	\matlab+hankel+. If any input is of type char: returns char output
Zh	3	3	3		1	1	1		true	true	true	true	if any( ~mod(in{1},1) & (in{1}<=0) )	hypergeometric function	\matlab+hypergeom+. If a numerator coefficient is a nonpositive integer the series is truncated at the first index for which a zero appears in the numerator, regardless of the denominator
													a = in{1}; b = in{2}; z = in{3};
													N = -max(a(~mod(a,1)));
													y = zeros(size(z));
													for k = 1:numel(z)
													for n = 0:N
													y(k) = y(k) + prod(prod(bsxfun(@plus, a, (0:n-1).'),2) ./ prod(bsxfun(@plus, b, (0:n-1).'),2) .* z(k) ./ (1:n).');
													end
													end
													out{1} = y; clear a b z y n N k
% The above is taken from hypergeom_comp.m
													else
													out{1} = hypergeom(in{:});
													end
i	0	2	0		1	1	1		true	true	true	true	if isempty(in), in{1} = defaultInputPrompt; end	input	\matlab+input+ with content checking. If $0$ inputs: uses default prompt string. \sa \matl+j+.
													if numel(in)==1, y = input(in{1},'s');
													valid = isempty(regexp(y, '^[^'']*(''[^'']*''[^'']*)*[a-df-hk-zA-EG-MOQ-SU-XZ]', 'once')) && isempty(regexp(y, '^[^'']*(''[^'']*''[^'']*)*[a-zA-Z]{2}', 'once'));
													assert(valid, 'MATL:runner', 'MATL run-time error: input not allowed')
													if isempty(y), y = []; else y = eval(y); end
													else y = input(in{:}); end
													out{1} = y;
													CB_G = [CB_G out(1)]; clear valid y
Xi	1	5	1		1	2	1		true	true	true	false	if isempty(strfind(in{1}, '://')), in{1} = ['http://' in{1}]; end;	return contents of a URL as a string	\matlab+urlread+. If the input string doesn't contain \matl+'://'+, the string \matl+'http://'+ is prepended
													[out{:}] = urlread(in{:});
Yi	1	inf	1		1	3	1		true	true	true	false	[out{:}] = imread(in{:});	read image from file	\matlab+imread+
Zi
j	0	1	0		1	1	1		true	true	true	true	if isempty(in), in{1} = defaultInputPrompt; end	input string	\matlab+input(..., 's')+. If $0$ inputs: uses default prompt string. \sa \matl+i+
													out{1} = input(in{1},'s');
													CB_G = [CB_G out(1)];
Xj	1	1	1		1	1	1		true	true	true	true	out{1} = real(in{:});	real part	\matlab+real+
Yj	1	1	1		1	1	1		true	true	true	true	out{1} = imag(in{:});	imaginary part	\matlab+imag+
Zj	1	1	1		1	2	1	2	true	true	true	true	if nout==1, out{1} = conj(in{1}); elseif nout==2, out = {real(in{1}), imag(in{1})}; end	complex conjugate / real and imaginary parts	(i) With one output: complex conjugate (\matlab+conj+). (ii) With two outputs: real and imaginary parts (\matlab+real+, \matlab+imag+)
k	1	1	1		1	1	1		true	true	true	true	if isnumeric(in{1}), out{1} = floor(in{1}); else, out{1} = lower(in{1}); end	convert string to lowercase / round towards minus infinity	\matlab+lower+ for strings or cell arrays; \matlab+floor+ for numerical arrays
Xk	1	1	1		1	1	1		true	true	true	true	if isnumeric(in{1}), out{1} = ceil(in{1}); else, out{1} = upper(in{1}); end	convert string to uppercase / round towards infinity	\matlab+upper+ for strings or cell arrays of strings; \matlab+ceil+ for numerical arrays
Yk	2	2	2		1	3	1	[false false true]	true	true	true	true	x = in{1}(:).'; y = in{2}(:); [dmin, ind] = min(abs(bsxfun(@minus, x, y)),[],1);	closest value	closest value in second input to each value in first input, in terms of absolute difference. For equidistant values it picks the one that appears first (in linear order) in the second input. Second output gives resulting absolute differences. Third output gives linear indices of selected elements
													out{1} = reshape(y(ind), size(in{1}));
													if nout>=2, out{2} = reshape(dmin, size(in{1})); end;
													if nout>=3, out{3} = reshape(ind, size(in{1})); end;
													clear x y ind dmin
Zk
l	0	inf	0	2	1	1	1		true	true	true	true	out{1} = ones(in{:});	array of ones	\matlab+ones+ (if $0$ inputs: produces output $1$)
Xl	2	3	2	3	1	1	1		true	true	true	true	if numel(in)==2, z = bsxfun(@min, in{1}, in{2});	clamp (limit to a range)	(i) With $2$ inputs, the minimum of the two inputs is computed, element-wise with singleton expansion. (ii) With $3$ inputs, the function computes the minimum between the first and the second, and then the maximum between that and the third, element-wise with singleton expansion. (i, ii) Output is \matlab+char+ if first input is. \sa \matl+X<+, \matl+X>+
													else z = bsxfun(@max, bsxfun(@min, in{1}, in{2}), in{3}); end
													if ischar(in{1}), z = char(z); end
													out{1} = z; clear z
Yl	1	2	1	2	1	1	1		true	true	true	true	if numel(in)==1, out{1} = log(in{1}); else out{1} = log(in{1})/log(in{2}); end	logarithm	\matlab+log+. If $2$ inputs: second input specifies logarithm base
Zl	1	1	1		1	2	1		true	true	true	true	[out{:}] = log2(in{:});	base 2 logarithm	\matlab+log2+
m	2	4	2		1	2	1	[false true]	true	true	true	true	if (iscell(in{1}) && (nnz(~cellfun(@ischar, in{1})) || isnumeric(in{2}))) || (iscell(in{2}) && (nnz(~cellfun(@ischar, in{2})) || isnumeric(in{1})))	true for set member	\matlab+ismember+. It also works for cell arrays with numeric content, or with mixed char/numeric content. \sa \matl+Xm+
													if ~iscell(in{1}), in{1} = in(1); end; if ~iscell(in{2}), in{2} = in(2); end
													[i2, i1] = ndgrid(1:numel(in{2}), 1:numel(in{1}));
													in1 = reshape(in{1}(i1), size(i1)); in2 = reshape(in{2}(i2), size(i2));
													e = cellfun(@isequal, in1, in2);
													[tf, ind] = max(e, [], 1); ind = ind.*tf;
													tf = reshape(tf, size(in{1})); ind = reshape(ind, size(in{1}));
													out{1} = tf; if nout>=2, out{2} = ind; end
													clear in1 in2 i1 i2 e tf ind
													else
													[out{:}] = ismember(in{:});
													end
Xm	2	3	2		1	2	1	[false true]	true	true	true	true	[out{:}] = ismember(in{1},in{2},'rows',in{3:end});	true for set member, row-wise	\matlab+ismember(..., 'rows', ...)+. \sa \matl+m+
Ym	1	4	1	2	1	1	1		true	true	true	true	str = {'omitnan' 'includenan' 'double' 'native' 'default'};	mean value	\matlab+mean+. This function allows flag strings in third and subsequent inputs to be replaced by numbers, as follows: 1: \matlab+'omitnan'+, 2: \matlab+'includenan'+, 3: \matlab+'double'+, 4: \matlab+'native'+, 5: \matlab+'default'+
													for k = 3:numel(in), if isnumeric(in{k}), in(k) = str(in{k}); end; end; clear str
													if ischar(in{1}), in{1} = double(in{1}); end; out{1} = mean(in{:});
Zm	1	2	2	1	1	1	1		true	true	true	true	if numel(in)==1, x=1; for t=in{1}(:).', x=lcm(x,t); end; out{1}=x;	least common multiple (element-wise, singleton expansion)	\matlab+lcm+, element-wise with singleton expansion. With $1$ input, computes the least common multiple of all elements of the input
													else
													if max(size(in{1}))==1 || max(size(in{2}))==1 || isequal(size(in{1}), size(in{2}))
													out{1} = lcm(in{:});
													else
													nd = max(ndims(in{1}), ndims(in{2})); sz1 = arrayfun(@(n)size(in{1},n), 1:nd); sz2 = arrayfun(@(n)size(in{2},n), 1:nd);
													assert(all(sz1==sz2 | sz1==1 | sz2==1), 'MATL:runtime', 'MATL run-time error: inputs have incompatible sizes')
													rm1 = ones(1,nd); rm1(sz1==1) = sz2(sz1==1); rm2 = ones(1,nd); rm2(sz2==1) = sz1(sz2==1);
													insx1 = repmat(in{1}, rm1); insx2 = repmat(in{2}, rm2); out{1} = lcm(insx1, insx2);
													clear nd sz1 sz2 rm1 rm2 insx1 insx2
													end
													end
n	1	1	1		1	inf	1	ndims(in{1})	true	true	true	true	if numel(out)==1	number of elements in array / size along each dimension	\matlab+numel+. For several outputs, or a single output other than the first, gives \matlab+size+ along those dimensions
													out{1} = numel(in{:});
													else
													[out{:}] = size(in{:});
													end
Xn	1	2	2	1	1	1	1		true	true	true	true	if numel(in)==2	binomial / multinomial coefficient (number of combinations)	(i) If $2$ inputs: \matlab+nchoosek+. This interprets first input as number(s). If the inputs are arrays, the function is computed element-wise with singleton expansion. For values \matlab+n+ and \matlab+k+ in first and second inputs, if \matlab+n+ is less than \matlab+k+ the result is \matlab+0+. (ii) If $1$ input: multinomial coefficient. The input contains the lower terms; their sum is the upper term. \sa \matl|XN|
													nd = max(ndims(in{1}), ndims(in{2})); sz1 = arrayfun(@(n)size(in{1},n), 1:nd); sz2 = arrayfun(@(n)size(in{2},n), 1:nd);
													assert(all(sz1==sz2 | sz1==1 | sz2==1), 'MATL:runtime', 'MATL run-time error: inputs have incompatible sizes')
													rm1 = ones(1,nd); rm1(sz1==1) = sz2(sz1==1); rm2 = ones(1,nd); rm2(sz2==1) = sz1(sz2==1);
													insx1 = repmat(in{1}, rm1); insx2 = repmat(in{2}, rm2);
													y = zeros(size(insx1)); ind = insx1>=insx2; y(ind) = arrayfun(@nchoosek, insx1(ind), insx2(ind));
													out{1} = y; clear nd sz1 sz2 rm1 rm2 insx1 insx2
													else
													out{1} = round(exp(gammaln(sum(in{1})+1) - sum(gammaln(in{1}+1))));
													end
% The code for implementing singleton expansion (through repmat) is taken from the code for the bitand function
Yn	1	5	2	4	1	1	1		true	true	true	true	if numel(in)==1	interpolation (table lookup) / convert roots to polynomial	(i) If $1$ input: \matlab+poly+. (ii) If $2$ or more inputs: \matlab+interp1+. With $2$ or $3$ numeric inputs, flags \matlab+'linear'+ and \matlab+'extrap'+ are assumed. \matlab+'pp'+ option not supported. A finite numeric value in the fourth input is replaced by a flag string, as follows: 1: \matlab+'linear'+, 2: \matlab+'nearest'+, 3: \matlab+'next'+, 4: \matlab+'previous'+, 5: \matlab+'spline'+, 6: \matlab+'pchip'+, 7: \matlab+'cubic'+, 8: \matlab+'v5cubic'+
													out{1} = poly(in{1});
													else
													str = {'linear' 'nearest' 'next' 'previous' 'spline' 'pchip' 'cubic' 'v5cubic'};
													for k = 4:min(numel(in),4), if isnumeric(in{k}) && isfinite(in{k}), in(k) = str(in{k}); end; end; clear str
													if numel(in)==2 || (numel(in)==3 && ~ischar(in{3})), in = [in {'linear' 'extrap'}]; end
													out{1} = interp1(in{:});
													end
Zn
o	1	3	1	2	1	1	1		true	true	true	true	if ~iscell(in{1})	convert to double precision array / modulo 2	(i) \matlab+double+. (ii) For cell array input behaves similarly to \matlab+char+: linearizes cell array, converts cell contents to \matlab+double+ and concatenates vertically, padding if needed. By default, padding is with zeros on the right. Optional second input indicates fill side: left if it evaluates to \matlab+false+, right if it evaluates to \matlab+true+. Third optional input specifies fill value. (iii) If input is already of type \matlab+double+: \matlab+mod(..., 2)+ 
													if ~isa(in{1}, 'double')
													out{1} = double(in{1});
													else
													out{1} = mod(in{1}, 2);
													end
													else
													in{1} = in{1}(:);
													n = max(cellfun(@(c) size(c,2), in{1}));
													if numel(in)>=2, lr = in{2}; else, lr = true; end
													if numel(in)>=3, fill = in{3}; else, fill = 0; end
													for k = 1:numel(in{1})
													if lr in{1}{k} = [double(in{1}{k}) repmat(fill, max(size(in{1}{k},1), 1), n-size(in{1}{k},2))];
													else in{1}{k} = [repmat(fill, max(size(in{1}{k},1), 1), n-size(in{1}{k},2)) double(in{1}{k})]; end
													end
													out{1} = vertcat(in{1}{:}); clear n fill lr
													end
Xo	1	1	1		1	1	1		true	true	true	true	out{1} = int64(in{1});	convert to signed 64-bit integer	\matlab+int64+
Yo	1	3	1	2	1	1	1		true	true	true	true	if isnumeric(in{1})	round towards nearest decimal or integer	(i) For numeric arrays: \matlab+round+. Third input can be a number instead of a string, as follows: 1: \matlab+'significant'+, 2: \matlab+'decimals'+. (ii) For character arrays or cell arrays of strings: change case
													str = {'significant' 'decimals'};
													if numel(in)>=3 && isnumeric(in{3}), in(3) = str(in{3}); end; clear str
													y = round(in{:});
													elseif ~iscell(in{1})
													x = in{1}(:).'; xlu = [lower(x); upper(x)];
													[~, ind] = max(bsxfun(@ne, x, xlu)); y = xlu(bsxfun(@plus, 0:2:2*(numel(x)-1), ind)); y = reshape(y,size(in{1}));
													else
													y = cell(size(in{1}));
													for n = 1:numel(in{1})
													x = in{1}{n}; xlu = [lower(x); upper(x)];
													[~, ind] = max(bsxfun(@ne, x, xlu)); y{n} = xlu(bsxfun(@plus, 0:2:2*(numel(x)-1), ind));
													end
													end
													out{1} = y; clear x xlu ind
Zo	1	1	1		1	1	1		true	true	true	true	out{1} = fix(in{:});	round to nearest integer towards zero	\matlab+fix+
p	1	3	1	2	1	1	1		true	true	true	true	if ischar(in{1}), in{1} = double(in{1}); end; out{1} = prod(in{:});	product of elements	\matlab+prod+. If first input is \matlab+char+ it is converted to \matlab+double+. \sa \matl|Xp|
Xp	1	3	1		1	1	1		true	true	true	true	if ischar(in{1}), in{1} = double(in{1}); end; out{1} = prod(in{1},1,in{2:end});	product along first dimension	\matlab+prod(..., 1, ...)+. If first input is \matlab+char+ it is converted to \matlab+double+. \sa \matl+p+.
Yp	1	4	1	2	1	1	1		true	true	true	true	if ischar(in{1}), in{1} = double(in{1}); end;	cumulative product	\matlab+cumprod+. Allows first input to be char. If $3$ numeric inputs: the third input is interpreted as a minimum which is applied after the product at each position. If $4$ numeric inputs: last two inputs are minimum and maximum respectively
													if numel(in)<=2 || (numel(in)==3 && ischar(in{3}))
													out{1} = cumprod(in{:});
													else
													if numel(in)==3, in{4} = inf; end
													x = permute(in{1}, [in{2} 1:in{2}-1 in{2}+1:ndims(in{1})]);
													indc = repmat({':'},1,ndims(in{1})-1);
													y = x;
													y(1,indc{:}) = min(max(y(1,indc{:}), in{3}), in{4});
													for k = 2:size(x,1)
													y(k,indc{:}) = y(k-1,indc{:}) .* x(k,indc{:});
													y(k,indc{:}) = min(max(y(k,indc{:}), in{3}), in{4});
													end
													y = ipermute(y, [in{2} 1:in{2}-1 in{2}+1:ndims(in{1})]);
													[out{1}] = y;
													end
Zp	1	1	1		1	1	1		true	true	true	true	if all(in{1}>=0)	is prime / totient function	For input with non-negative entries: \matlab+isprime+. For input with non-positive entries: Euler's totient function for absolute value of each entry
													if ischar(in{1}), in{1} = double(in{1}); end, out{1} = isprime(in{1});
													elseif all(in{1}<=0)
													in{1} = -in{1}; tot = NaN(size(in{1}));
													for n = 1:numel(in{1}), tot(n) = sum(gcd(in{1}(n),1:in{1}(n))==1); end
													out{1} = tot;
													else
													error('MATL:runtime', 'MATL run-time error: input should have all entries positive or all non-positive')
													end
q	1	1	1		1	1	1		true	true	true	true	out{1} = in{1}-1;	decrement by 1	\matlab+(...)-1+
Xq	2	3	2	3	1	1	1		true	true	true	true	out{1} = quantile(in{:});	quantiles of a sample	\matlab+quantile+
Yq	1	1	1		1	1	1		true	true	true	true	if all(in{1}>0)	n-th prime / next prime	For input with positive entries: $n$-th prime for each value $n$ in the input array. For input with non-positive entries: next prime for absolute value of each entry
													N = max(in{1}(:)); p = primes(max(11,ceil(N*log(N*log(N))))); out{1} = reshape(p(in{1}), size(in{1})); clear N p
													elseif all(in{1}<=0)
													in{1} = -floor(in{1}); np = NaN(size(in{1}));
													for k=1:numel(np), np(k) = in{1}(k)+1; while ~isprime(np(k)), np(k)=np(k)+1; end, out{1} = np; end, clear k np
													else
													error('MATL:runtime', 'MATL run-time error: input should have all entries positive or all non-positive')
													end
Zq	1	1	1		1	1	1		true	true	true	true	out{1} = primes(in{1});	prime numbers up to a given value	\matlab+primes+
r	0	inf	0	2	1	1	1		true	true	true	true	out{1} = rand(in{:});	uniformly distributed pseudorandom numbers	\matlab+rand+
Xr	0	inf	0	2	1	1	1		true	true	true	true	if numel(in)==0, in{1} = 1; end; out{1} = randn(in{:});	normally distributed pseudorandom numbers	\matlab+randn+
Yr	1	inf	1	2	1	1	1		true	true	true	true	if numel(in)==2 && isscalar(in{2}), in{2} = [1 in{2}]; end	pseudorandom integers from uniform discrete distribution	\matlab+randi+. If the first input is a vector of $2$ elements it is automatically sorted. With $2$ inputs, if the second input is a scalar \matlab+n+ it is transformed into \matlab+[1 n]+
													if numel(in{1})==2, in{1} = sort(in{1}); end
													out{1} = randi(in{:});
Zr	2	4	2	3	1	1	1		true	true	true	true	out{1} = randsample(in{:});	random sample	\matlab+randsample+. Does not support stream specification
s	1	4	1	2	1	1	1		true	true	true	true	str = {'omitnan' 'includenan' 'double' 'native' 'default'};	sum	\matlab+sum+. This function allows flag strings in third and subsequent inputs to be replaced by numbers, as follows: 1: \matlab+'omitnan'+, 2: \matlab+'includenan'+, 3: \matlab+'double'+, 4: \matlab+'native'+, 5: \matlab+'default'+. \sa \matl+Xs+
													for k = 3:numel(in), if isnumeric(in{k}), in(k) = str(in{k}); end; end; clear str
													out{1} = sum(in{:});
Xs	1	3	1		1	1	1		true	true	true	true	str = {'omitnan' 'includenan' 'double' 'native' 'default'};	sum along first dimension.	\matlab+sum(..., 1, ...)+. This function allows flag strings in third and subsequent inputs to be replaced by numbers, as follows: 1: \matlab+'omitnan'+, 2: \matlab+'includenan'+, 3: \matlab+'double'+, 4: \matlab+'native'+, 5: \matlab+'default'+. \sa \matl+s+
													for k = 2:numel(in), if isnumeric(in{k}), in(k) = str(in{k}); end; end; clear str
													out{1} = sum(in{1},1,in{2:end});
Ys	1	4	1	2	1	1	1		true	true	true	true	if ischar(in{1}), in{1} = double(in{1}); end;	cumulative sum	\matlab+cumsum+. Allows first input to be char. Optional third and fourth numerical scalar inputs are interpreted as minimum and maximum values, which are applied after the sum at each position. These can be substituted by a 2-element numerical array as second or third input
													if (numel(in)==1) || (numel(in)==2 && numel(in{2})==1) || (numel(in)==3 && ischar(in{3}))
													out{1} = cumsum(in{:});
													else
													if numel(in)==4
													d = in{2}; m = in{3}; M = in{4};
													elseif numel(in)==3 && numel(in{3})==2
													d = in{2}; m = in{3}(1); M = in{3}(2);
													elseif numel(in)==3 && numel(in{3})==1
													d = in{2}; m = in{3}; M = inf;
													elseif numel(in)==2 && numel(in{2})==2
													[~, d] = max(size(in{1})-1); m = in{2}(1); M = in{2}(2);
													else
													error('MATL:runtime', 'MATL run-time error: incorrect input')
													end
													x = permute(in{1}, [d 1:d-1 d+1:ndims(in{1})]);
													indc = repmat({':'},1,ndims(in{1})-1);
													y = x;
													y(1,indc{:}) = min(max(y(1,indc{:}), m), M);
													for k = 2:size(x,1)
													y(k,indc{:}) = y(k-1,indc{:}) + x(k,indc{:});
													y(k,indc{:}) = min(max(y(k,indc{:}), m), M);
													end
													y = ipermute(y, [d 1:d-1 d+1:ndims(in{1})]);
													out{1} = y; clear d m M x y
													end
Zs	1	4	1	2	1	1	1		true	true	true	true	if ischar(in{1}), in{1} = double(in{1}); end;	standard deviation / covariance matrix	\matlab+std+. With $2$ inputs \matlab+x+, \matlab+f+ and \matlab+f+ equal to $2$ or $3$, gives \matlab+cov(x, f-2)+
													if numel(in)==1 || (numel(in)==2 && in{2}<=1) || numel(in)>2
													out{1} = std(in{:});
													else
													out{1} = cov(in{1}, in{2}-2);
													end
t	0	inf	1		0	0	0		false	true	false	true	out = in;	duplicate elements	duplicate elements in stack. The duplicated elements are those specified as inputs
Xt
Yt
Zt	3	3	3		1	1	1		true	true	true	true	if ischar(in{1}) || iscell(in{1})	replace substring with another	(i) If first input is char or a cell array: \matlab+strrep+. Numerical second and third inputs are converted to char. (ii) The first input can be a numerical or logical array (not a cell array of numeric or logical arrays). In this case the other inputs can be char, numeric or logical (not cell); each input array is linearized; result is a row vector; and result has the type of the third input, even if no substitutions have been actually done
													if isnumeric(in{2}), in{2} = char(in{2}); end
													if isnumeric(in{3}), in{3} = char(in{3}); end
% The above two lines are needed {in Matlab and in Octave} if in{1} is cell, and are needed {only in Octave} if in{1} is char
													out{1} = strrep(in{:});
													else
													t = in{1}(:).'; p = in{2}(:).'; r = in{3}(:).'; m = numel(p); n = numel(r);
													y = []; mem = false;
% This line above defines y as double. We will cast to char or logical at the end if needed
													while numel(t)
													if isequal(t(1:min(m,end)), p)
													y = [y r]; t = t(2:end); mem = true;
													elseif mem
													if numel(t)>=m
													y = [y t(m)];
													end
													t = t(m+1:end); mem = false;
													else
													y = [y t(1)]; t = t(2:end);
													end
													end
% The above `while` loop implements the logic of `strrep`. It's complicated, because of overlapping patterns. This is handled by variable `mem`
													if ischar(in{3}), y = char(y); end
													if islogical(in{3}), y = logical(y); end
													out{1} = y; clear t p r m n mem
													end
u	1	4	1		1	4	1		true	true	true	true	str = {'stable' 'sorted' 'last' 'first' 'rows'};	unique	\matlab+unique+, with \matlab+'stable'+ option by default. It includes a fourth output with the count for each unique element. It also allows cell array input with numeric content, or mixed char/numeric content. In this case it only works with a single output, either in sorted or stable mode. This function allows flag strings in second and subsequent inputs to be replaced by numbers, as follows: 1: \matlab+'stable'+, 2: \matlab+'sorted'+, 3: \matlab+'last'+, 4: \matlab+'first'+, 5: \matlab+'rows'+. \sa \matl+Xu+
													for k = 2:numel(in), if isnumeric(in{k}), in(k) = str(in{k}); end; end; clear str
													if numel(in)==1 || (numel(in)==2 && strcmp(in{2}, 'rows')), in{end+1} = 'stable'; end
													if iscell(in{1}) && ~ischar(in{1}{1})
													if numel(in)>=2 && isequal(in{end},'sorted')
% Sort lexicographically. This is taken from the code of `S`:
													n = max(cellfun(@numel, in));
													x = cellfun(@(t) [t(:).' -inf(1,n-numel(t))], in{1}, 'uniformoutput', 0);
													x = vertcat(x{:});
													[~, ind] = sortrows(x); in{1} = in{1}(ind);
													end
													[ii, jj] = ndgrid(1:numel(in{1}));
													ind = ~any(triu(cellfun(@isequal, in{1}(ii), in{1}(jj)),1),1);
													y = in{1}(ind); y = y(:);
													if ndims(in{1})==2 && size(in{1},1)==1, y = y.'; end
													out{1} = y; out = out(1:nout); clear y ii jj
													else
													[out{1:min(nout,3)}] = unique(in{:});
													if nout==4
													id = out{3}; count = sum(bsxfun(@eq, id(:), 1:max(id)), 1).';
													out{4} = count; clear id count
													end
													end
Xu	1	3	1		1	4	1		true	true	true	true	str = {'stable' 'sorted' 'last' 'first'};	unique rows	\matlab+unique(..., 'rows', ...)+, with \matlab+'stable'+ option by default. It includes a fourth output with the count for each unique row. This function allows flag strings in second and subsequent inputs to be replaced by numbers, as follows: 1: \matlab+'stable'+, 2: \matlab+'sorted'+, 3: \matlab+'last'+, 4: \matlab+'first'+. \sa \matl+u+
													for k = 2:numel(in), if isnumeric(in{k}), in(k) = str(in{k}); end; end; clear str
													if numel(in)<=1, in{end+1} = 'stable'; end
													[out{1:min(nout,3)}] = unique(in{1}, 'rows', in{2:end});
													if nout==4
													id = out{3}; count = sum(bsxfun(@eq, id(:), 1:max(id)), 1).';
													out{4} = count; clear id count
													end
Yu
Zu	2	2	2		1	1	1		true	true	true	true	str = {'right' 'left' 'center'};	justify character array	\matlab+strjust+. Strings in second input to be replaced by numbers, as follows: 1: \matlab+'right'+, 2: \matlab+'left'+, 3: \matlab+'center'+
													if isnumeric(in{2}), in(2) = str(in{2}); end; clear str
													out{1} = strjust(in{:});
v	0	inf	numel(STACK)	2	1	1	1		true	true	true	true	if any(diff(nonzeros(cellfun(@(x) size(x,2), in))))	vertical concatenation	\matlab+vertcat+. If inputs are matrices with non-matching sizes they are linearized
													in = cellfun(@(x) reshape(x,[],1), in, 'uniformoutput', false);
													end
													if any(cellfun(@ischar, in))
													for k = 1:numel(in)
													if islogical(in{k}), in{k} = double(in{k}); end
													end
													end
													out{1} = vertcat(in{:});
Xv
Yv	1	2	1		1	3	1	[false true false]	true	true	true	true	if isnumeric(in{1})	eigen- or singular-value decomposition / remove insignificant whitespace	(i) If input is numeric: with $1$ or $2$ outputs: \matlab+eig+. With $3$ outputs: \matlab+svd+. (ii) If input is a string or cell array of strings: \matlab+strtrim+. For string or char array input, char $0$ also counts as whitespace
													if nout<=2
													[out{:}] = eig(in{:});
													elseif nout==3
													if islogical(S_OUT) && isequal(S_OUT, [false true false]), out = {NaN svd(in{:}) NaN}; else [out{:}] = svd(in{:}); end
													else error('MATL:runtime', 'MATL run-time error: incorrect number of inputs')
													end
													else
													if ischar(in{1})
													s = find(~all(ismember(in{1}, [0 9 10 11 12 13 32]),1), 1, 'first');
													e = find(~all(ismember(in{1}, [0 9 10 11 12 13 32]),1), 1, 'last');
													in{1} = in{1}(:,s:e);
													end; clear s e
% The above is needed to include 0 as whitespace
													out{1} = strtrim(in{:});
													end
Zv	1	2	1	2	1	1	1		true	true	true	true	if (numel(in)==1) && (numel(in{1})==1) && isnumeric(in{1})	symmetric range / symmetric array / remove trailing blanks	(i) For one numeric input \matlab+n+: symmetric range. For nonnegative \matlab+n+ it rounds down and then gives \matlab+[1:n n-1:-1:1]+; for negative \matlab+n+ it removes sign, rounds down and gives \matlab+[n:-1:1 2:n]+. (ii) For two inputs: applies symmetric range indexing to the first input along each dimension given by the (linearized) second input. The indexing along a given dimension doesn't repeat the last entry if the dimension is positive, and repeats it if it is negative. (iii) For one string or cell array input: \matlab+deblank+
													if in{1}>=0, in{1} = floor(in{1}); out{1} = [1:in{1} in{1}-1:-1:1]; else, in{1} = floor(-in{1}); out{1} = [in{1}:-1:1 2:in{1}]; end
													elseif numel(in)==1
													out{1} = deblank(in{:});
													else
													result = in{1};
													for k = in{2}(:).'
													removeLast = k>0; dim = abs(k);
													inds = repmat({':'}, 1, ndims(result)); inds{dim} = [1:size(result, dim) size(result, dim)-removeLast:-1:1];
													result = result(inds{:});
													end
													out{1} = result;
													clear k inds dim removeLast result
													end
w	0	inf	2		0	0	0		false	true	false	true	if ~isempty(in), in([1 end]) = in([end 1]); STACK(end+nin) = in; end	swap elements in stack	swap elements in stack
Xw
Yw
Zw
x	0	inf	1		0	0	0		true	true	false	true	;	delete	delete from stack
Xx	0	1	0	1	0	0	0		true	true	true	true	if numel(in)==1, if islogical(in{1}), if in{1}, in{1} = 10; else, in{1} = 2.5; end; end, pause(in{1}/10); end; clc	clear window	\matlab+clc+. With $1$ input \matlab+x+: \matlab+pause(x/10)+ and then \matlab+clc+. Inputs \matl+F+ and \matl+T+ are interpreted as \matl+2.5+ and \matl+10+ respectively
Yx
Zx
y	0	inf	2	3	0	0	0		false	true	false	true	out = in(1);	duplicate element	duplicate one element in stack. The duplicated element is the lowest among those specified as inputs
Xy	1	4	1		1	1	1		true	true	true	true	out{1} = eye(in{:});	identity matrix	\matlab+eye+ (matrix with ones on diagonal and zeros elsewhere)
Yy	2	2	2		1	1	1		true	true	true	true	out{1} = bsxfun(@hypot, in{1}, in{2});	hypotenuse (element-wise, singleton expansion)	\matlab+hypot+, element-wise with singleton expansion
Zy	1	2	1		1	inf	1		true	true	true	true	[out{:}] = size(in{:});	size	\matlab+size+
z	1	1	1		1	1	1		true	true	true	true	out{1} = nnz(in{:});	number of nonzero elements	\matlab+nnz+
Xz	1	1	1		1	1	1		true	true	true	true	if iscell(in{1}), out{1} = regexprep(in{1}, '[\s\0]', ''); elseif ischar(in{1}), out{1} = regexprep(reshape(in{1},1,[]), '[\s\0]', ''); else, out{1} = nonzeros(in{:}); end	nonzero elements / remove whitespace	\matlab+nonzeros+. If input is a string or char array: removes whitespace, including \matlab+char(0)+; the result is a string. If input is cell array of strings: operates on each string
Yz
Zz
{
X{	1	2	1	2	1	1	1		true	true	true	true	out{1} = num2cell(in{:});	convert numeric array into cell array	\matlab+num2cell+
Y{	2	inf	3	2	1	1	1		true	true	true	true	out{1} = mat2cell(in{:});	break up array into cell array of subarrays	\matlab+mat2cell+
Z{	1	1	1		1	1	1		true	true	true	true	sz = num2cell(size(in{1})); out{1} = mat2cell(in{1}, ones(sz{1},1), sz{2:end});	cell array of first-dimension slices from array	\matlab+mat2cell(x, ones(size(x,1),1), size(x,2),...,size(x,ndims(x)))+. It's a generalization of \matlab+cellstr+ that works for numeric, logical or char arrays of any number of dimensions
|	1	2	1	2	1	1	1		true	true	true	true	if numel(in)==1, out{1} = abs(in{1});	absolute value / norm / determinant	If $1$ input: \matlab+abs+. If $2$ inputs, second input non-zero: \matlab+norm+. If $2$ inputs, second input zero: \matlab+det+, or \matlab+sqrt(det(A*A.'))+ for first input \matlab+A+ non-square
													elseif in{2}==0 && ~diff(size(in{1})), out{1} = det(in{1});
													elseif in{2}==0 && diff(size(in{1})), out{1} = sqrt(det(in{1}*in{1}.'));
													else out{1} = norm(in{:});
													end
X|	2	4	2	3	1	3	1		true	true	true	true	str = {'rows' 'stable' 'sorted'};	set union	\matlab+union+. Uses the \matlab+'stable'+ flag by default. If one input is char and the other is numeric, the latter is converted to char. This function allows flag strings in third and subsequent inputs to be replaced by numbers, as follows: 1: \matlab+'rows'+, 2: \matlab+'stable'+, 3: \matlab+'sorted'+
													for k = 3:numel(in), if isnumeric(in{k}), in(k) = str(in{k}); end; end; clear str
													if ischar(in{1}) && isnumeric(in{2}), in{2} = char(in{2}); end
													if ischar(in{2}) && isnumeric(in{1}), in{1} = char(in{1}); end
													if numel(in)==2 || (numel(in)==3 && strcmp(in{3},'rows')), in{end+1}='stable'; end, [out{:}] = union(in{:});
Y|	0	inf	2	numel(STACK)	1	1	1		true	true	true	true	if isempty(in), y = false; else y = in{1}; for n=2:numel(in), y = bsxfun(@or, y, in{n}); end; end; if numel(in)==1, y = logical(y); end; out{1} = y; clear y n;	logical 'or' (element-wise, singleton expansion)	\matlab+|+ (\matlab+or+), element-wise with singleton expansion
Z|	2	3	2		1	1	1		true	true	true	true	if ischar(in{1}), in{1} = double(in{1}); end; if ischar(in{2}), in{2} = double(in{2}); end	bit-wise logical 'or' (element-wise, singleton expansion)	\matlab+bitor+ (bitwise 'or'), element-wise with singleton expansion. If first or second inputs are \matlab+char+ they are converted to \matlab+double+. \matlab+double+ inputs are rounded. If the inputs are \matlab+double+ they can have negative values, and in that case they must be in the range from \matlab+-2^52+ up to \matlab+2^52-1+. \sa \matl+Z&+, \matl+Z~+
													in{1} = round(in{1}); in{2} = round(in{2});
													if any(in{1}(:)<0) || any(in{2}(:)<0), neg = true; else neg = false; end
													if neg, in{1} = mod(in{1}, 2^53); in{2} = mod(in{2}, 2^53); end;
													if max(size(in{1}))==1 || max(size(in{2}))==1 || isequal(size(in{1}), size(in{2}))
													out{1} = bitor(in{:});
													else
													nd = max(ndims(in{1}), ndims(in{2})); sz1 = arrayfun(@(n)size(in{1},n), 1:nd); sz2 = arrayfun(@(n)size(in{2},n), 1:nd);
													assert(all(sz1==sz2 | sz1==1 | sz2==1), 'MATL:runtime', 'MATL run-time error: inputs have incompatible sizes')
													rm1 = ones(1,nd); rm1(sz1==1) = sz2(sz1==1); rm2 = ones(1,nd); rm2(sz2==1) = sz1(sz2==1);
													insx1 = repmat(in{1}, rm1); insx2 = repmat(in{2}, rm2); out{1} = bitor(insx1, insx2, in{3:end});
													clear nd sz1 sz2 rm1 rm2 insx1 insx2
													end
													if neg, out{1} = mod(out{1} - 2^52, 2^53) - 2^52; end; clear neg
}
X}
Y}
Z}	1	2	1	2	0	inf	-2		true	true	true	true	if numel(in)==1, sz = size(in{1}); [~, d] = max(sz>1); in{2} = d; end;	split array	split array into subarrays along the first non-singleton dimension. With $2$ inputs: split into subarrays along the dimension indicated by the second input
													d = num2cell(size(in{1})); d{in{2}} = ones(1,size(in{1},in{2})); out = mat2cell(in{1}, d{:}); out = out(:).'; clear d
													if nout>=0, out = out(1:nout); end
~	1	1	1		1	1	1		true	true	true	true	out{1} = ~in{1};	logical 'not' (element-wise)	\matlab+~+ (\matlab+not+)
X~	2	4	2	3	1	3	1		true	true	true	true	str = {'rows' 'stable' 'sorted'};	set exclusive-or (symmetric difference)	\matlab+setxor+. Uses the \matlab+'stable'+ flag by default. If one input is char and the other is numeric, the latter is converted to char. This function allows flag strings in third and subsequent inputs to be replaced by numbers, as follows: 1: \matlab+'rows'+, 2: \matlab+'stable'+, 3: \matlab+'sorted'+. \sa \matl+X-+
													for k = 3:numel(in), if isnumeric(in{k}), in(k) = str(in{k}); end; end; clear str
													if ischar(in{1}) && isnumeric(in{2}), in{2} = char(in{2}); end
													if ischar(in{2}) && isnumeric(in{1}), in{1} = char(in{1}); end
													if numel(in)==2, in{3}='stable'; end, [out{:}] = setxor(in{:});
Y~	2	2	2		1	1	1		true	true	true	true	out{1} = bsxfun(@xor, in{1}, in{2});	logical 'xor' (element-wise, singleton expansion)	\matlab+xor+, element-wise with singleton expansion
Z~	2	3	2		1	1	1		true	true	true	true	if ischar(in{1}), in{1} = double(in{1}); end; if ischar(in{2}), in{2} = double(in{2}); end	bit-wise logical 'xor' (element-wise, singleton expansion)	\matlab+bitxor+ (bitwise 'xor'), element-wise with singleton expansion. If first or second inputs are \matlab+char+ they are converted to \matlab+double+. \matlab+double+ inputs are rounded. If the inputs are \matlab+double+ they can have negative values, and in that case they must be in the range from \matlab+-2^52+ up to \matlab+2^52-1+. \sa \matl+Z&+, \matl+Z|+
													in{1} = round(in{1}); in{2} = round(in{2});
													if any(in{1}(:)<0) || any(in{2}(:)<0), neg = true; else neg = false; end
													if neg, in{1} = mod(in{1}, 2^53); in{2} = mod(in{2}, 2^53); end;
													if max(size(in{1}))==1 || max(size(in{2}))==1 || isequal(size(in{1}), size(in{2}))
													out{1} = bitxor(in{:});
													else
													nd = max(ndims(in{1}), ndims(in{2})); sz1 = arrayfun(@(n)size(in{1},n), 1:nd); sz2 = arrayfun(@(n)size(in{2},n), 1:nd);
													assert(all(sz1==sz2 | sz1==1 | sz2==1), 'MATL:runtime', 'MATL run-time error: inputs have incompatible sizes')
													rm1 = ones(1,nd); rm1(sz1==1) = sz2(sz1==1); rm2 = ones(1,nd); rm2(sz2==1) = sz1(sz2==1);
													insx1 = repmat(in{1}, rm1); insx2 = repmat(in{2}, rm2); out{1} = bitxor(insx1, insx2, in{3:end});
													clear nd sz1 sz2 rm1 rm2 insx1 insx2
													end
													if neg, out{1} = mod(out{1} - 2^52, 2^53) - 2^52; end; clear neg